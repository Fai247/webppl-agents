// Run as: webppl test.wppl --require .

// Examples and Tests:
// Examples of running agent on different gridworlds.
// Basic tests of overall agent perfomance and gridworld library. 

// use *runAllTests* to run unit and integration tests.


// BASIC EXAMPLE:
// Sample trajectories in the (4,3) grid
// with transition noise but no softmax noise.

// Output is array of trajectories of form [ state0, state1, ... , state5 ]
var sampleGrid43 = function(numberSamples){
  var noiseProb = .1;
  var alpha = 100;
  var actualTotalTime = 6;
  
  var params = make43(noiseProb, alpha);
  var numberRejectionSamples = 1000;
  var output = 'states';
  var getExpUtilityValues = false;
  var out = mdpSimulate([0,0], actualTotalTime, actualTotalTime, params, numberRejectionSamples,
                        getExpUtilityValues, output);
  return repeat(numberSamples, function(){return map(function(pair){return pair[0];}, sample(out.erp));});
};


// Donut/Veg Cafe from AAAI paper. Four terminal states, with
// Veg Cafe best in this example. 
var runDonutExample = function(){
  var noiseProb = 0;
  var alpha = 30;
  var actualTotalTime = 7;
  
  var params = makeDonut(noiseProb, alpha);
  displayGrid(params);
  var startState = [2,0];
  var getExpUtilityValues = false;
  var output = 'both';
  var numberRejectionSamples = 1000;
  var out = mdpSimulate(startState, actualTotalTime, actualTotalTime, params, numberRejectionSamples,
                        getExpUtilityValues, output);
  GridWorld.zipToDisplayGrid( out.erp.MAP().val, params.xLim, params.yLim, true )
  return out.erp.MAP().val;
};




// EXAMPLE AND TESTS OF MDP SOLVING WITH DIFFERENT OUTPUTS AND DISPLAYS
// Print the grid with *displayGrid*.
// Print agent trajectory with *zipToDisplayGrid*/
// Compute *expUtilityValues*, which are the expected utilities of
// the state-action pairs the agent chose on MAP sequence.
// Assert result for MAP sequence equals predictions. 

// Test on a 3x3 grid with no blocked cells and on Russell-Norvig (4,3) grid. 

var smallGridTest = function(){

  // clean up output for display
  var clean = function(ar){return map(function(pair){return pair[0][0] + JSON.stringify(pair[0][1]);},ar)};
  
  var runGrid = function(makeGrid, noiseProb, alpha, startState, actualTotalTime, numberRejectionSamples){
    var params = makeGrid(noiseProb, alpha);
    displayGrid(params);
    var perceivedTotalTime = actualTotalTime;
    var getExpUtilityValues = true;
    var output = 'both';
    var out = mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples,
                          getExpUtilityValues, output);
    var outMAP = out.erp.MAP().val;
    console.log('\n\n DISPLAY MAP PATH OF STATE-ACTIONS')
    GridWorld.zipToDisplayGrid( outMAP, params.xLim, params.yLim, true );
    console.log('\n\n ExpUtility of state-actions pairs in MAP sequence of state-actions: \n ', 
                out.expUtilityValues, ' \n\n MAP sequence ', outMAP);
    console.log('\n\n Sample trajectories from Posterior', repeat( 8, function(){return clean(sample(out.erp));}) );
    return selectIndex(outMAP,0); // output MAP state sequence
  };

  console.log('\n Small grid, non-stochastic transition, alpha=10 \n------------');
  var makeGrid = makeSmall;
  var startState = [0,0];
  var mapStates = runGrid(makeGrid, 0, 5, startState, 6,0);
  assert.ok(gridEqual(last(mapStates), [2,2]), 'agent only reaches terminal on last state due to softmax');
  
  console.log('\n\n SMALL GRID 2: stochastic transitions, alpha=100 \n--------------');
  var mapStates = runGrid(makeGrid, 0.1, 100, startState, 5, 500);
  assert.ok(gridEqual(last(mapStates), [2,2]), 'agent is at terminal on final state');
  
  console.log('\n\n\n Russell-Norvig 4,3 grid, noise=.25, alpha=100 \n --------------');
  var mapStates = runGrid(make43, .25, 100, [0,0], 6, 500);
  assert.ok(gridEqual(mapStates[1], [0,1]), 'agent goes up with first action');

  console.log('\n All tests in *smallGridTest* passed');
};



// Unit tests for gridworld constructor functions

var testInGrid = function(){
  assert.ok(inGrid(4,4,[0,0]) & inGrid(4,4,[3,2]) & inGrid(4,4,[3,3]) & inGrid(2,2,[1,1]), 'ingrid' );
  assert.ok( !(inGrid(4,4,[1.5,0]) | inGrid(4,4, ['u',0]) | inGrid(4,4,[-1,0]) |
               inGrid(4,4, [1.5,10]) | inGrid(2,2,[2,0]) | inGrid(4,4,['1',0]) ), 'ingrid' )
  console.log('passed testInGrid');
};

var testTransition = function(){
  var t = makeGridTransition(4,4,[],[]);
  assert.ok(  gridEqual( t([0,0],'l'), [0,0]) & 
              gridEqual( t([0,0],'r'), [1,0]) &  
              gridEqual( t([0,0],'u'), [0,1]), 'testTransition1' );
  
  var t = makeGridTransition(4, 4, [ [1,0], [1,1], [3,3] ],[]);

  assert.ok(  gridEqual( t([0,0],'l'), [0,0]) &
              gridEqual( t([0,0],'r'), [0,0]) & 
              gridEqual( t([0,0],'u'), [0,1]) & 
              gridEqual( t([0,1],'r'), [0,1]) &
              gridEqual( t([1,2],'d'), [1,2]) &
              gridEqual( t([2,3],'r'), [2,3]) &
              gridEqual( t([3,2],'u'), [3,2]), 'testTransition2'); 
  var t = makeStochasticGridTransition(4, 4, [ [1,0], [1,1], [3,3] ], .000000001, []);
  assert.ok(  gridEqual( t([0,0],'l'), [0,0]) &
              gridEqual( t([0,0],'r'), [0,0]) & 
              gridEqual( t([0,0],'u'), [0,1]) & 
              gridEqual( t([0,1],'r'), [0,1]) &
              gridEqual( t([1,2],'d'), [1,2]) &
              gridEqual( t([2,3],'r'), [2,3]) &
              gridEqual( t([3,2],'u'), [3,2]), 'testTransition3');

  
  var t = makeStochasticGridTransition(4, 4, [ ], .5, []);
  var thunk = function(){return t([1,1],'u');};
  var erp = Enumerate( thunk );
  assert.ok( gridEqual( erp.MAP().val, [1,2] ) )
  assert.ok( filter(function(pair){return gridEqual([0,1],pair);}, repeat(1000, thunk) ), 'testStoch' )
  
  console.log('passed transition');
};


var runAllTests = function(){
  smallGridTest();
  testInGrid();
  testTransition();
};



0;
