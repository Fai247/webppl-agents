

var openToBlocked = function(open, xLim, yLim){
  var fullGrid = getFullGrid(xLim, yLim);
  return filter( function(state){return !stateInArray(state,open);}, fullGrid);
};


var makeDonutInfer = function(smallVersion, utilityTable, alpha, noiseProb){
  

  var smallParams = {openStates : [ [0,0], [0,1],
                                    [1,1], [1,4],
                                    [2,0], [2,1], [2,2], [2,3], [2,4], [2,5],
                                    [3,3], [3,5], [3,6],
                                    [4,2], [4,3], [4,4], [4,5] ],
                     xLim: 5,
                     yLim: 7,
                     terminals:  [[0,0], [1,4], [4,2], [3,6] ],
                     stateToRestaurantTable: { '[0,0]': 'donutSouth',
                                               '[1,4]': 'donutNorth', 
                                               '[3,6]':'veg',
                                               '[4,2]': 'noodle' }
                    };
  
  var bigParams = {openStates: [[0,0], [0,1],
                                [1,1],
                                [2,1], [2,5],
                                [3,0], [3,1], [3,2], [3,3], [3,4], [3,5], [3,6],
                                [4,3], [4,6], [4,7],
                                [5,2], [5,3], [5,4], [5,5], [5,6] ],
                   xLim: 6,
                   yLim: 8,
                   terminals:  [[0,0], [2,5], [5,2], [4,7] ],
                   stateToRestaurantTable: { '[0,0]': 'donutSouth',
                                             '[2,5]': 'donutNorth', 
                                             '[4,7]':'veg',
                                             '[5,2]': 'noodle' }
                  };
  
  var params = smallVersion ? smallParams : bigParams;
  var blockedStates = openToBlocked(params.openStates, params.xLim, params.yLim);

  var stateToRestaurant = function(state){
    var table = params.stateToRestaurantTable;
    return table[JSON.stringify(state)] ? table[JSON.stringify(state)] : false;
  };
  
  var u = function(state,action){
    if (isPostTerminal(state)){return 0;};
    if (stateToRestaurant(state)){return utilityTable[ stateToRestaurant(state) ];}
    return utilityTable['timeCost'];
  };
  return makeBlockedGridParams(params.xLim, params.yLim, blockedStates, params.terminals, u, noiseProb, alpha);
};




var utilityTable = {'donutSouth': 1, 'donutNorth':1, 'veg':2.1, 'noodle':2, 'timeCost':-.6};
var alpha = 4;
var params = donutInfer(utilityTable,alpha,0);
displayGrid(params);
var startState = [2,0];
var actualTotalTime = 8;
var perceivedTotalTime = 8;
var numberRejectionSamples = 500;

var out = mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples, 
                      true, 'both', undefined);
var erp = out.erp;
var lenERP = Enumerate(function(){return sample(erp).length;});
printERP(lenERP);

GridWorld.zipToDisplayGrid( erp.MAP().val, params.xLim, params.yLim, true );
console.log('expU', out.expUtilityValues);

//console.log( erp.MAP().val, sample(erp), sample(erp), sample(erp), sample(erp));

ash();


var logERPs = function(erps){
  map( function(erp){
    console.log('\n\n new erp:');
    printERP(erp);}, erps);
};


var xLim = 4;
var yLim = 3;

var makeFour = function(noiseProb, alpha, uNorth, uSouth){
  var utility = function(state,action){
    if (gridEqual(state,[3,2]) ){ return uNorth;}
    if (gridEqual(state,[3,0]) ){ return uSouth;}
    if (isPostTerminal(state)){ return 0;}
    return -.1;
  };
  var blockedStates = [[1,1] ];
  var terminals = [[3,2], [3,0]];
  return makeBlockedGridParams(4,3, blockedStates, terminals, utility, noiseProb, alpha);
};


// TODO change alpha back

var runFour = function(startState, perceivedTotalTime, uNorth, uSouth, display, conditionOnStates,
                      actualTotalTime){
  assert.ok(startState.length==2 & perceivedTotalTime>0 & typeof(uNorth)=='number'  & typeof(uSouth)=='number', 
            'runFour');
  
  var actualTotalTime = 1 || actualTotalTime;
  assert.ok(perceivedTotalTime >= actualTotalTime, 'perceive');
  var numberRejectionSamples = 0;
  var output = 'actionOnly';

  var noiseProb = 0;
  var alpha = 5 //30 //100;
  
  var params = makeFour(noiseProb, alpha, uNorth, uSouth);
  if (display){displayGrid(params); console.log(' \n\n');}
  var getExpUtilityValues = true;
  return mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples,
                     getExpUtilityValues, output, conditionOnStates);
  
};


// Condition on a sequence [ [state,action] ]
// Get an ERP for each state.
// do  map( function(stateERP_action){ factor(stateERP([], action)) } )

// this should have same runtime as conditioning on a single action -- right a test for this



var runSequenceInfer = function(startState, perceivedTotalTime, uNorthValues, uSouthValues,
                                observedStateActions, numRejectionSamples, useMCMC){
  assert.ok( typeof(uNorthValues[0])=='number' &  typeof(uSouthValues[0])=='number' & 
             numRejectionSamples >= 0  &  observedStateActions[0][0].length == 2 & 
             observedStateActions[0][1].length==1, 'runSimpleInfer' );


  // test gen model
  var out = mdpSimulate(startState, perceivedTotalTime, perceivedTotalTime, 
                        makeFour(0, 100, 10, -10), 100, false, 'both');
  //console.log('\n\n sample from gen model ', sample(out.erp));

  
  // structural params
  var Infer = Enumerate;

  var inferViz = false;
  if (inferViz){console.log('Infer structural parms: startState, perceivedTotalTime, numRejectionSamples', 
                       startState, perceivedTotalTime, numRejectionSamples);}

  var conditionOnStates = selectIndex(observedStateActions,0);
  var observedActions = selectIndex(observedStateActions,1);


  return Infer( function(){
    
    var uNorth = uniformDraw(uNorthValues);
    var uSouth = uniformDraw(uSouthValues);


    var out = timeit( function(){return runFour(startState, perceivedTotalTime, uNorth, uSouth, false, 
                                                conditionOnStates);} );
    var time = out.runtimeInMilliseconds;
    var erp = out.value.erp;
    if (inferViz){console.log('Inf sample: (uN, uS, runtime for genModel):', uNorth, uSouth, time, '\nERP on actions' );
      printERP(erp);
    }
    
    var stateERPs = out.value.stateActionERPs;
    var stateERPs_actions = zip(stateERPs,observedActions);

    // logERPs(stateERPs);
    // console.log('stateERPs_actions:', stateERPs_actions, '\n')

    //console.log('\n N and S', uNorth, uSouth);
    map( function(stateERP_action){
      var stateERP = stateERP_action[0];
      var action = stateERP_action[1];
      //console.log('\n score: ', Math.exp(stateERP.score([],action)));
      factor(stateERP.score([],action) );
    }, stateERPs_actions);

    //factor( erp.score([],observedAction) );  TODO reinstate for test
    
    return {uNorth: uNorth, uSouth: uSouth};
  });
};

var testSequenceInfer = function(){
  var startState = [0,0];
  var uNorthValues = [-10,10];
  var uSouthValues = [-10,10];
  var display = false;
  var fullSequence = [ [[0,0],'u'], [[0,1],'u'], [[0,2],'r'], [[1,2],'r'], [[2,2],'r'], [[3,2],'r'] ];     
  var perceivedTotalTime = fullSequence.length;
  var numRejectionSamples = 0;
  
  map( function(sequenceLength){
    var observedStateActions = fullSequence.slice(0,sequenceLength);  
    var out = timeit( function(){return runSequenceInfer(startState, perceivedTotalTime, uNorthValues, uSouthValues,
                                                         observedStateActions, numRejectionSamples, undefined);});
    var erp = out.value;
    printERP(erp);
    console.log('(sequenceLength, time): ', sequenceLength, out.runtimeInMilliseconds);
  }, [1,2,3,4,5,6]);
};

testSequenceInfer();

ash();







// infer from a single action

var runSimpleInfer = function(startState, perceivedTotalTime, uNorthValues, uSouthValues,
                              observedAction, numRejectionSamples, useMCMC){
  assert.ok( typeof(uNorthValues[0])=='number' &  typeof(uSouthValues[0])=='number' & 
             numRejectionSamples >= 0, 'runSimpleInfer' );
  
  // structural params
  var Infer = numRejectionSamples==0 ? Enumerate: function(f){return Rejection(f,numRejectionSamples);};
  var Infer = useMCMC ? function(f){return MCMC(f,{samples:numRejectionSamples});} : Infer;

  var inferViz = false;
  if (inferViz){console.log('Infer structural parms: startState, perceivedTotalTime, numRejectionSamples', 
                       startState, perceivedTotalTime, numRejectionSamples);}

  
  return Infer( function(){
    
    var uNorth = uniformDraw(uNorthValues);
    var uSouth = uniformDraw(uSouthValues);
    
    var out = timeit( function(){return runFour(startState, perceivedTotalTime, uNorth, uSouth, false);} );
    var time = out.runtimeInMilliseconds;
    var erp = out.value.erp;
    if (inferViz){
      console.log('Inference sample: (uN, uS, runtime for genModel):', uNorth, uSouth, time, '\nERP on actions' );
      printERP(erp);
    }
    
    factor( erp.score([],observedAction) );
    
    return {uNorth: uNorth, uSouth: uSouth};
  });
};


var testEnumerate = function(perceivedTotalTime, numNorthValues){
  // Test Enumerate. Runtime is not much more than genModel * number_utility_functions

  var startState = [0,0];
  var uNorthValues = [1, -10,-9,-8,-7,-6,5,-4,-3,-2,-1].slice(0,numNorthValues);
  var uSouthValues = [-10,0.5];
  var observedAction = ["u"];
  var numRejectionSamples = 0;

  // time the generative model
  var display = false;
  var genModelOut = timeit(function(){return runFour(startState, perceivedTotalTime, 
                                                     last(uNorthValues), uSouthValues[0], display);} );
  var inferOut = timeit(function(){
    return runSimpleInfer(startState, perceivedTotalTime, uNorthValues, uSouthValues, observedAction, numRejectionSamples, false); 
  });

  var erp = inferOut.value;
  var inferTime = inferOut.runtimeInMilliseconds;

  assert.ok( erp.MAP().val.uNorth == 1, 'uNorth in testInfer');
  var genTimesValues =  genModelOut.runtimeInMilliseconds * uNorthValues.length * uSouthValues.length;
  assert.ok( 2*genTimesValues > inferTime, 'genTimesValues, with extra factor of 2');

  console.log('\n\nTIME: genModel: genModel*values == infer ? ',genModelOut.runtimeInMilliseconds,':  ', genTimesValues, inferTime);             
  printERP(erp);
};


var runTestEnumerate = function(){
  map( function(totalTime_k){testEnumerate(totalTime_k[0],totalTime_k[1]);},
       [ [6,2], [7,2], [8,2], [6,3], [7,4], [8,5] ] );
  console.log('all test enumerate passed');
};

runTestEnumerate();
ash();



// var uNorth = -10;
// var uSouth = 1;
// var startState = [2,2];

// var out = timeit( function(){return runFour(uNorth, uSouth, startState);} );
// var time = out.runtimeInMilliseconds;
// var erp = out.value.erp;
// var expU = out.value.expUtilityValues;

// console.log('time: ', time);

// var viz = true;
// if (viz){
//   GridWorld.zipToDisplayGrid( erp.MAP().val, xLim, yLim, true );
//   GridWorld.displayExpUtility(expU, xLim, yLim);
//   console.log('map, prob: \n ', erp.MAP().val, erp.MAP().prob);
// };
// ash();
