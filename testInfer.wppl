


var testMakeDonutInfer = function(){
  var alpha = 100;   // LOW NOISE
  var noiseProb = 0;
  var actualTotalTime = 9;
  var perceivedTotalTime = 9;
  var numberRejectionSamples = 100;  
  
  var runDonut = function(smallVersion, utilityTable){
    var params = makeDonutInfer(smallVersion, utilityTable, alpha, noiseProb);
    var startState = params.defaultStartState;
    var out = mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples, 
                      true, 'both', undefined);
    var erp = out.erp;
    console.log('size: ', smallVersion, 'u table', utilityTable, '\n');
    GridWorld.zipToDisplayGrid( erp.MAP().val, params.xLim, params.yLim, true );
  };    
  // goes to veg despite distance
  runDonut(true, {'donutSouth': 1, 'donutNorth':1, 'veg':3, 'noodle':2, 'timeCost':-.1});
  runDonut(false, {'donutSouth': 1, 'donutNorth':1, 'veg':3, 'noodle':2, 'timeCost':-.1});

  // donutSouth because of timeCost
  runDonut(true, {'donutSouth': 1, 'donutNorth':1, 'veg':3, 'noodle':2, 'timeCost':-1});
  runDonut(false, {'donutSouth': 1, 'donutNorth':1, 'veg':3, 'noodle':2, 'timeCost':-1});

  // softmax noise leads to variable trajectory length
  var alpha = 5;
  var noiseProb = 0;
  var actualTotalTime = 10;
  var perceivedTotalTime = 10;
  var numberRejectionSamples = 100;  
  
  var runSoftmax = function(smallVersion, utilityTable){
    var params = makeDonutInfer(smallVersion, utilityTable, alpha, noiseProb);
    var startState = params.defaultStartState;
    var out = mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples, 
                          true, 'both', undefined);
    var erp = out.erp;
    var lengthERP = Enumerate( function(){return sample(erp).length;} );
    console.log('size: ', smallVersion, 'u table', utilityTable, '\n');
    printERP(lengthERP);
    GridWorld.zipToDisplayGrid( erp.MAP().val, params.xLim, params.yLim, true );
  };    
  runSoftmax(true, {'donutSouth': 1, 'donutNorth':1, 'veg':2, 'noodle':2, 'timeCost':-.3});
  runSoftmax(false, {'donutSouth': 1, 'donutNorth':1, 'veg':2, 'noodle':2, 'timeCost':-.3});

  
  // speed test for small grid - vary only perceivedTotalTime
  var alpha = 100;
  var noiseProb = 0;
  var actualTotalTime = 1;
  var numberRejectionSamples = 0;  
  
  var runSpeed = function(smallVersion, utilityTable, perceivedTotalTime){
    var params = makeDonutInfer(smallVersion, utilityTable, alpha, noiseProb);
    var startState = params.defaultStartState;
    return mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples, 
                      true, 'both', undefined).erp;
  };
  var utilityTable = {'donutSouth': 1, 'donutNorth':1, 'veg':3, 'noodle':2, 'timeCost':-.1};
  
  map( function(perceivedTotalTime){
    var out = timeit( function(){return runSpeed(true, utilityTable, perceivedTotalTime)});
    console.log('perceivedTime, runtime in ms: ', perceivedTotalTime, out.runtimeInMilliseconds);
  }, [6,7,8,9] );
  
};



var logERPs = function(erps){
  map( function(erp){
    console.log('\n\n new erp:');
    printERP(erp);}, erps);
};

var xLim = 4;
var yLim = 3;

// Corners grid is a variant of 4-3 world, with terminals in the corners

// Display grid ('#' means wall)

// [ 2:  '-0.1', '-0.1', '-0.1', '1t'  ]
// [ 1:  '-0.1',   '#',  '-0.1', '-0.1']
// [ 0:  '-0.1', '-0.1', '-0.1', '-1t' ]
// [        0,     1,        2  ,  3   ]

var makeCorners = function(noiseProb, alpha, uNorth, uSouth){
  var utility = function(state,action){
    if (gridEqual(state,[3,2]) ){ return uNorth;}
    if (gridEqual(state,[3,0]) ){ return uSouth;}
    if (isPostTerminal(state)){ return 0;}
    return -.1;
  };
  var blockedStates = [[1,1] ];
  var terminals = [[3,2], [3,0]];
  return makeBlockedGridParams(4,3, blockedStates, terminals, utility, noiseProb, alpha);
};


// TODO change alpha back

var runFour = function(startState, perceivedTotalTime, uNorth, uSouth, display, conditionOnStates,
                      actualTotalTime){
  assert.ok(startState.length==2 & perceivedTotalTime>0 & typeof(uNorth)=='number'  & typeof(uSouth)=='number', 
            'runFour');
  
  var actualTotalTime = 1 || actualTotalTime;
  assert.ok(perceivedTotalTime >= actualTotalTime, 'perceive');
  var numberRejectionSamples = 0;
  var output = 'actionOnly';

  var noiseProb = 0;
  var alpha = 5 //30 //100;
  
  var params = makeCorners(noiseProb, alpha, uNorth, uSouth);
  if (display){displayGrid(params); console.log(' \n\n');}
  var getExpUtilityValues = true;
  return mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples,
                     getExpUtilityValues, output, conditionOnStates);
  
};


// Condition on a sequence [ [state,action] ]
// Get an ERP for each state.
// do  map( function(stateERP_action){ factor(stateERP([], action)) } )

// this should have same runtime as conditioning on a single action -- right a test for this



var runSequenceInfer = function(startState, perceivedTotalTime, uNorthValues, uSouthValues,
                                observedStateActions, numRejectionSamples, useMCMC){
  assert.ok( typeof(uNorthValues[0])=='number' &  typeof(uSouthValues[0])=='number' & 
             numRejectionSamples >= 0  &  observedStateActions[0][0].length == 2 & 
             observedStateActions[0][1].length==1, 'runSimpleInfer' );


  // test gen model
  var out = mdpSimulate(startState, perceivedTotalTime, perceivedTotalTime, 
                        makeCorners(0, 100, 10, -10), 100, false, 'both');
  //console.log('\n\n sample from gen model ', sample(out.erp));

  
  // structural params
  var Infer = Enumerate;

  var inferViz = false;
  if (inferViz){console.log('Infer structural parms: startState, perceivedTotalTime, numRejectionSamples', 
                       startState, perceivedTotalTime, numRejectionSamples);}

  var conditionOnStates = selectIndex(observedStateActions,0);
  var observedActions = selectIndex(observedStateActions,1);


  return Infer( function(){
    
    var uNorth = uniformDraw(uNorthValues);
    var uSouth = uniformDraw(uSouthValues);


    var out = timeit( function(){return runFour(startState, perceivedTotalTime, uNorth, uSouth, false, 
                                                conditionOnStates);} );
    var time = out.runtimeInMilliseconds;
    var erp = out.value.erp;
    if (inferViz){console.log('Inf sample: (uN, uS, runtime for genModel):', uNorth, uSouth, time, '\nERP on actions' );
      printERP(erp);
    }
    
    var stateERPs = out.value.stateActionERPs;
    var stateERPs_actions = zip(stateERPs,observedActions);

    // logERPs(stateERPs);
    // console.log('stateERPs_actions:', stateERPs_actions, '\n')

    //console.log('\n N and S', uNorth, uSouth);
    map( function(stateERP_action){
      var stateERP = stateERP_action[0];
      var action = stateERP_action[1];
      //console.log('\n score: ', Math.exp(stateERP.score([],action)));
      factor(stateERP.score([],action) );
    }, stateERPs_actions);

    //factor( erp.score([],observedAction) );  TODO reinstate for test
    
    return {uNorth: uNorth, uSouth: uSouth};
  });
};

var testSequenceInfer = function(){
  var startState = [0,0];
  var uNorthValues = [-10,10];
  var uSouthValues = [-10,10];
  var display = false;
  var fullSequence = [ [[0,0],'u'], [[0,1],'u'], [[0,2],'r'], [[1,2],'r'], [[2,2],'r'], [[3,2],'r'] ];     
  var perceivedTotalTime = fullSequence.length;
  var numRejectionSamples = 0;
  
  map( function(sequenceLength){
    var observedStateActions = fullSequence.slice(0,sequenceLength);  
    var out = timeit( function(){return runSequenceInfer(startState, perceivedTotalTime, uNorthValues, uSouthValues,
                                                         observedStateActions, numRejectionSamples, undefined);});
    var erp = out.value;
    printERP(erp);
    console.log('(sequenceLength, time): ', sequenceLength, out.runtimeInMilliseconds);
  }, [1,2,3,4,5,6]);
};

testSequenceInfer();

ash();







// infer from a single action

var runSimpleInfer = function(startState, perceivedTotalTime, uNorthValues, uSouthValues,
                              observedAction, numRejectionSamples, useMCMC){
  assert.ok( typeof(uNorthValues[0])=='number' &  typeof(uSouthValues[0])=='number' & 
             numRejectionSamples >= 0, 'runSimpleInfer' );
  
  // structural params
  var Infer = numRejectionSamples==0 ? Enumerate: function(f){return Rejection(f,numRejectionSamples);};
  var Infer = useMCMC ? function(f){return MCMC(f,{samples:numRejectionSamples});} : Infer;

  var inferViz = false;
  if (inferViz){console.log('Infer structural parms: startState, perceivedTotalTime, numRejectionSamples', 
                       startState, perceivedTotalTime, numRejectionSamples);}

  
  return Infer( function(){
    
    var uNorth = uniformDraw(uNorthValues);
    var uSouth = uniformDraw(uSouthValues);
    
    var out = timeit( function(){return runFour(startState, perceivedTotalTime, uNorth, uSouth, false);} );
    var time = out.runtimeInMilliseconds;
    var erp = out.value.erp;
    if (inferViz){
      console.log('Inference sample: (uN, uS, runtime for genModel):', uNorth, uSouth, time, '\nERP on actions' );
      printERP(erp);
    }
    
    factor( erp.score([],observedAction) );
    
    return {uNorth: uNorth, uSouth: uSouth};
  });
};


var testEnumerate = function(perceivedTotalTime, numNorthValues){
  // Test Enumerate. Runtime is not much more than genModel * number_utility_functions

  var startState = [0,0];
  var uNorthValues = [1, -10,-9,-8,-7,-6,5,-4,-3,-2,-1].slice(0,numNorthValues);
  var uSouthValues = [-10,0.5];
  var observedAction = ["u"];
  var numRejectionSamples = 0;

  // time the generative model
  var display = false;
  var genModelOut = timeit(function(){return runFour(startState, perceivedTotalTime, 
                                                     last(uNorthValues), uSouthValues[0], display);} );
  var inferOut = timeit(function(){
    return runSimpleInfer(startState, perceivedTotalTime, uNorthValues, uSouthValues, observedAction, numRejectionSamples, false); 
  });

  var erp = inferOut.value;
  var inferTime = inferOut.runtimeInMilliseconds;

  assert.ok( erp.MAP().val.uNorth == 1, 'uNorth in testInfer');
  var genTimesValues =  genModelOut.runtimeInMilliseconds * uNorthValues.length * uSouthValues.length;
  assert.ok( 2*genTimesValues > inferTime, 'genTimesValues, with extra factor of 2');

  console.log('\n\nTIME: genModel: genModel*values == infer ? ',genModelOut.runtimeInMilliseconds,':  ', genTimesValues, inferTime);             
  printERP(erp);
};


var runTestEnumerate = function(){
  map( function(totalTime_k){testEnumerate(totalTime_k[0],totalTime_k[1]);},
       [ [6,2], [7,2], [8,2], [6,3], [7,4], [8,5] ] );
  console.log('all test enumerate passed');
};

runTestEnumerate();
ash();



// var uNorth = -10;
// var uSouth = 1;
// var startState = [2,2];

// var out = timeit( function(){return runFour(uNorth, uSouth, startState);} );
// var time = out.runtimeInMilliseconds;
// var erp = out.value.erp;
// var expU = out.value.expUtilityValues;

// console.log('time: ', time);

// var viz = true;
// if (viz){
//   GridWorld.zipToDisplayGrid( erp.MAP().val, xLim, yLim, true );
//   GridWorld.displayExpUtility(expU, xLim, yLim);
//   console.log('map, prob: \n ', erp.MAP().val, erp.MAP().prob);
// };
// ash();
