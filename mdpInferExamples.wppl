// To run script:
// webppl mdpInferExamples.wppl --require webppl-timeit --require webppl-dp --require .


//------------------
// Inference examples for *mdpSimulate*

// Condition on a sequence of state-action pairs. Show that
// inference runtime is constant in length of sequence, holding
// fixed the agent's *perceiveTotalTime* and keeping the *actualTotalTime* set to 1.

// *runSimpleInfer* shows that conditioning on single action has runtime close to
// generative model * number of U functions. 

// Examples all use simple variant of Russell-Norvig 4-3 world, where
// the two terminals are in the top right and left corners. 
// -------------------




// GRIDWORLD MDP FOR ALL INFERENCE EXAMPLES

// *Corners Grid* is a variant of 4-3 world, with terminals in the corners

// Grid: ('#' means 'wall')

// [ 2:  '-0.1', '-0.1', '-0.1', '1t'  ]
// [ 1:  '-0.1',   '#',  '-0.1', '-0.1']
// [ 0:  '-0.1', '-0.1', '-0.1', '-1t' ]
// [        0,     1,        2  ,  3   ]

var makeCorners = function(noiseProb, alpha, uNorth, uSouth){
  var utility = function(state,action){
    if (gridEqual(state,[3,2]) ){ return uNorth;}
    if (gridEqual(state,[3,0]) ){ return uSouth;}
    if (isPostTerminal(state)){ return 0;}
    return -.1;
  };
  var blockedStates = [[1,1] ];
  var terminals = [[3,2], [3,0]];
  return makeBlockedGridParams(4,3, blockedStates, terminals, utility, noiseProb, alpha);
};

// Run agent on Corners grid for a SINGLE timestep, i.e. *actualTotalTime=1* with *alpha=5*
var runCorners = function(startState, perceivedTotalTime, uNorth, uSouth, conditionOnStates){
  assert.ok(startState.length==2 & perceivedTotalTime>0 & typeof(uNorth)=='number'  & typeof(uSouth)=='number', 
            'runCorners args');
  
  var actualTotalTime = 1;
  var noiseProb = 0;
  var alpha = 5;
  var params = makeCorners(noiseProb, alpha, uNorth, uSouth);

  // mdpSimulate arguments
  var numberRejectionSamples = 0;  // use Enumerate for distribution on agent actions
  var getExpUtilityValues = false;
  var output = 'actionOnly';  // output for mdpSimulate is array of form [ action0, action1, ... ] 

  return mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples,
                     getExpUtilityValues, output, conditionOnStates);
};



// INFERENCE FUNCTIONS

// GOAL: Condition on a sequence [ [state,action] ] by running agent for single action
// and pulling an ERP for each state in the sequence from mdpSimulate

// If we hold fixed the *perceivedTotalTime* for the agent when taking the single action
// then the runtime for inference should be constant as function of the length
// of the sequence (where sequence.length <= perceivedTotalTime).

// *runSequenceInfer* implements this inference (using *mdpSimulate*'s argument *conditionOnStates*)
// *testRunSequenceInfer* checks that the runtime has constant scaling


var runSequenceInfer = function(startState, perceivedTotalTime, uNorthValues, uSouthValues, observedStateActions){
  assert.ok( typeof(uNorthValues[0])=='number' &  typeof(uSouthValues[0])=='number' & observedStateActions[0][0].length == 2 & 
             observedStateActions[0][1].length==1, 'runSequenceInfer args' );

  var conditionOnStates = selectIndex(observedStateActions,0);
  var observedActions = selectIndex(observedStateActions,1);

  return Enumerate( function(){    
    var uNorth = uniformDraw(uNorthValues);
    var uSouth = uniformDraw(uSouthValues);

    // run mdp agent with utilities given by (uNorth,uSouth).
    // out.stateActionERP is array of ERPs over actions for each state in *conditionOnStates*
    var out = runCorners(startState, perceivedTotalTime, uNorth, uSouth, conditionOnStates);
    
    var stateERPs = out.stateActionERPs;
    var stateERPs_actions = zip(stateERPs,observedActions);

    // score for each action, given the hypothetical ERP for actions given each state in *conditionOnStates*
    map( function(stateERP_action){
      var stateERP = stateERP_action[0];
      var action = stateERP_action[1];
      factor(stateERP.score([],action) );
    }, stateERPs_actions);
    
    return {uNorth: uNorth, uSouth: uSouth};
  });
};

var testRunSequenceInfer = function(){
  console.log('testSequencInfer start ... ');
  var startState = [0,0];
  var uNorthValues = [-10,10,30];
  var uSouthValues = [-10,10];
  var fullSequence = [ [[0,0],'u'], [[0,1],'u'], [[0,2],'r'], [[1,2],'r'],
                       [[2,2],'d'], [[2,1],'d'], [[2,0],'r'], [[3,0],'r'] ];     
    
  var perceivedTotalTime = fullSequence.length;

  // Computing runtime information for generative model (no inference)
  var genModel = timeit(function(){runCorners(startState, perceivedTotalTime, uNorthValues[0], uSouthValues[0], undefined);});
  console.log('Time in ms for (timeit generative model * # utilityFunctions): ', 
              genModel.runtimeInMilliseconds * uNorthValues.length * uSouthValues.length, '\n');
                   
  // Runtime for inference conditioning on subsequence of every length up to maximum
  map( function(sequenceLength){
    var observedStateActions = fullSequence.slice(0,sequenceLength);  
    var out = timeit( function(){return runSequenceInfer(startState, perceivedTotalTime, uNorthValues,
                                                         uSouthValues, observedStateActions);});
    var erp = out.value;
    console.log('\nLength of *conditionStates* trajectory: timeit: ', 
                sequenceLength, '\: ', out.runtimeInMilliseconds, '\n ERP: \n');
    printERP(erp);
  },  _.range(1,fullSequence.length));
};




// GOAL: Condition utilities on a single action. (Using *mdpSimulate* to generate an ERP on the first action, and not
// using the *conditionOnStates* machinery). Show that inference with Enumerate has runtime
// close to the generative model * # utilityFunctions.


// Do inference in Corners generative model
var runSimpleInfer = function(startState, perceivedTotalTime, uNorthValues, uSouthValues, observedAction, InferFunction){
  assert.ok( typeof(uNorthValues[0])=='number' &  typeof(uSouthValues[0])=='number', 'runSimpleInfer' );
  
  return InferFunction( function(){
    
    var uNorth = uniformDraw(uNorthValues);
    var uSouth = uniformDraw(uSouthValues);
    
    var out = runCorners(startState, perceivedTotalTime, uNorth, uSouth, undefined);
    var erp = out.erp;
    
    factor( erp.score([],observedAction) );
    
    return {uNorth: uNorth, uSouth: uSouth};
  });
};

// Agent is observed taking one step UP, which makes sense only if uNorth is better.
// The only uNorth value where this holds is uNorth=1, so our MAP should have this. 
var testRunSimpleInfer = function(perceivedTotalTime, numNorthValues){
  var startState = [0,0];
  var uNorthValues = [1, -10,-9,-8,-7,-6,5,-4,-3,-2,-1].slice(0,numNorthValues);
  var uSouthValues = [-10,0.5];
  var observedAction = ["u"];
  var InferFunction = Enumerate;

  // time the generative model
  var genModelOut = timeit(function(){return runCorners(startState, perceivedTotalTime, last(uNorthValues), uSouthValues[0], undefined);} );

  // time inference
  var inferOut = timeit(function(){
    return runSimpleInfer(startState, perceivedTotalTime, uNorthValues, uSouthValues, observedAction, InferFunction);
  });

  var erp = inferOut.value;
  var inferTime = inferOut.runtimeInMilliseconds;

  // test inference correctness
  assert.ok( erp.MAP().val.uNorth == 1, 'uNorth in testInfer');

  // compare runtime for generative model vs. inference
  var genTimesValues =  genModelOut.runtimeInMilliseconds * uNorthValues.length * uSouthValues.length;
  assert.ok( 2*genTimesValues > inferTime, 'genTimesValues, with extra factor of 2');

  console.log('\n\nTIME: genModel: genModel*values == infer ? ',
              genModelOut.runtimeInMilliseconds,':  ', genTimesValues, inferTime);             
  printERP(erp);
};

// Test for various values of perceivedTotalTime and number of utility functions
var loopTestRunSimpleInfer = function(){
  map( function(totalTime_k){testRunSimpleInfer(totalTime_k[0],totalTime_k[1]);},
       [ [6,2], [7,2], [8,2], [6,3], [7,4], [8,5] ] );
  console.log('all test enumerate passed');
};

testRunSequenceInfer();
loopTestRunSimpleInfer();
