// POMDP agent model

// TODO: test gridworld POMDPs

// Helper functions
var zeroes = function(n){return repeat(n, function(){return 0;})};
var ones = function(n){return repeat(n, function(){return 1;})};
var inArray = function(x, xs){return indexOf(x, xs) != undefined;};
var range = function(n){
    assert.ok(typeof(n) == 'number', 'tried to take the range of something that isnt a number');
    if (n < 0) {
	return [];
    } else {
	return snoc(range(n - 1), n);
    }
};
// a repackaging of JSON.stringify that you can map onto arrays
var stringify = function(thing){
    return JSON.stringify(thing);
};
var stringChar = function(string, num) {
    assert.ok(typeof(string) == 'string' && typeof(num) == 'number', 'args to stringChar');
    return string.charAt(num);
};

// Helper functions because functions can't be called using "dot" notation
var startStatePrior = function(params){
  var f = params.startStatePrior;
  return f();
};

var stateToActions = function(state,params){
  var f = params.stateToActions;
  return f(state);
};

var getManifestState = function(state, params){
  var f = params.getManifestState;
  return f(state);
};

var utility = function(state, action, params){
  var f = params.utility;
  return f(state, action);
};

var transition = function(state,action,params){
  var f = params.transition;
  return f(state, action);
};

var observe = function(state,params){
  var f = params.observe;
  return f(state);
};



// ---------------------------------------


// POMDP GENERATIVE MODELS - two different versions of POMDP simulate

var buildState = function(manifestState,latentState){
  return {manifestState:manifestState, latentState:latentState};
};



// ----Update-less POMDP Simulate------
// Stores all observations in memory. When it needs a posterior, it does the
// belief update in batch on all the observations in its memory. For
// efficiency, it filters out uninformative observations (they never get stored in memory)
// and it caches computations of the posterior. 


var pomdpSimulate = function(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples){

  // Add a pair [state,observation] to memory only if it will make a difference to
  // belief updating
  var updateMemory = function(oldMemory, manifestState, newObservation, params){
    assert.ok( _.isArray(oldMemory) & _.isString(manifestState) & 
               (_.isString(newObservation) | _.isNumber(newObservation) ), 'updateMemory args');
    
    var oldStates = selectIndex(oldMemory,0);
    
    if ( (newObservation=='noObservation') | 
         (params.deterministicObservations & inArray(manifestState, oldStates))){
      return oldMemory;
    } else {return push(oldMemory,[manifestState,newObservation]);}
  };
  
 
  // In bandit case, agent's uncertainty is about the *latentState*, i.e.
  // the utility function on states. We sample a setting of *latentState*
  // from the agent's prior. We then compute the observations that *would* arise
  // given that setting (*hypotheticalObservation*). We check if these match the actual
  // observations. 
  var getPosteriorLatent = dp.cache( 
    function(manifestState_Observation_pairs, params){
      var observationEquality = params.observationEquality;
      
      return Enumerate( function(){
        var hypotheticalLatentState = startStatePrior(params).latentState;
        
        map( function( manifestState_Observation ){
          var manifestState = manifestState_Observation[0];
          var actualObservation = manifestState_Observation[1];
          var hypotheticalState = buildState(manifestState, hypotheticalLatentState);
          var hypotheticalObservation = observe( hypotheticalState, params);
     
          condition( observationEquality(hypotheticalObservation, actualObservation) ); // should be factor     
        }, manifestState_Observation_pairs);
        
        return hypotheticalLatentState;
      });
    });
  


  // agent is called on *manifestState* not *state* since he doesn't know his *state*
  var agent = dp.cache( 
  function(manifestState, timeLeft, memory, params){    // update belief: currentBelief, observation
    assert.ok(timeLeft>0 & _.isArray(memory) & _.isString(manifestState) & params.actions.length>0, 'agent args');
    
    return Enumerate( function(){
      var posterior = getPosteriorLatent(memory, params);
      var action = uniformDraw(params.actions);
      
      var expectedUtility = expectation(
        Enumerate(function(){
          var state = buildState(manifestState, sample(posterior));
          assert.ok(getManifestState(state, params) == manifestState, 'check on state');
          return expUtility(state, action, timeLeft, memory, params);   
        }));
      
      factor(params.alpha * expectedUtility);
      return action;
    });
  });
  
  // expUtility takes a state (not manifestState) because agent is computing value of a state (integrating over
  // a posterior distribution on latentStates)

  var expUtility = dp.cache(
    function(state, action, timeLeft, memory, params){
      var u = utility(state, action, params);
      
      if (timeLeft - 1 == 0){
        return u;
      } else {                     
        return u + expectation( Enumerate(function(){
          var nextState = transition(state, action, params);
          var nextMemory = updateMemory(memory, getManifestState(nextState, params), observe(nextState,params), params );   
          var nextAction = sample(agent(getManifestState(nextState, params), timeLeft-1, nextMemory, params));
          return expUtility(nextState, nextAction, timeLeft-1, nextMemory, params);
        }));
      }                      
    });
  

  var simulate = function(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples){
    assert.ok(  actualTotalTime <= perceivedTotalTime  &  _.isString(startState.manifestState), 'simulate args');
    
    var sampleSequence = function(state, actualTimeLeft, perceivedTimeLeft, history, memory){
      assert.ok( actualTimeLeft>=0  & perceivedTimeLeft>=0 &  _.isArray(memory) & _.isArray(history), 'sample sequence args');
      
      if (actualTimeLeft==0){
        return history.slice(0,history.length-1);
      } else {
        
        var action = sample(agent( getManifestState(state, params), perceivedTimeLeft, memory, params));
        var nextState = transition(state, action, params);
        var nextMemory = updateMemory(memory, getManifestState(nextState, params), observe(nextState,params), params); 
        var nextHistory = push(history, nextState);
        
        return sampleSequence(nextState, actualTimeLeft-1, perceivedTimeLeft-1, nextHistory, nextMemory);
      }
    };
    
    var N = numberRejectionSamples;
    var InferFunction = (N==0) ? Enumerate : function(f){return Rejection(f,N, undefined, true);};
    
    return InferFunction(function(){    
      var startHistory = [startState];
      var startMemory = updateMemory( [], getManifestState(startState, params), observe(startState, params), params);
      return sampleSequence(startState, actualTotalTime, perceivedTotalTime, startHistory, startMemory);
      
    });                 
  };
  
  return simulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples);
};




// ---POMDPSimulate for agent that updates beliefs-----

// The same as previous agent but this time does belief
// updating and stores no memories. This is the standard
// Bayesian agent, computing posterior updates in an online fashion.

// Currently, this agent does not filter out observations which
// will not result in any update (i.e. "noObservation" observations).
// However, the agent does cache belief updates. So if called in the
// same manifestState, time and prior and observation, it will return
// the same ERP without recomputing. 

var updatePOMDPSimulate = function(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples){
  var isERP = function(x){return x.hasOwnProperty('score') & x.hasOwnProperty('sample');}
  var observationEquality = params.observationEquality;

  // takes an ERP and updates it on a single observation. Since *observe* takes
  // a state (not a latentState) we need to build a state from the sampled latentState. 
  var updateBelief = dp.cache(
    function(currentBelief, manifestState, observation, params){
      return Enumerate( function(){
        var hypotheticalLatentState = sample(currentBelief);
        var hypotheticalState = buildState(manifestState, hypotheticalLatentState);
        var hypotheticalObservation = observe(hypotheticalState, params);
        condition( observationEquality(hypotheticalObservation, observation) );
        return hypotheticalLatentState;
      });
    });
  

  // agent is called on *manifestState* not *state* since he doesn't know his *state*
  // NB: agent outputs an action and an updated belief. This way, *expUtility* can
  // iteratively simulate future choices by passing through the agent's updated belief.
  var agent = dp.cache( 
    function(manifestState, timeLeft, currentBelief, observation, params){
	// console.log(manifestState, " ", observation);
      assert.ok(timeLeft>0  & isERP(currentBelief) & _.isString(manifestState) & params.actions.length>0, 'agent args');
    return Enumerate( function(){
      var updatedBelief = updateBelief(currentBelief, manifestState, observation, params);
      var action = uniformDraw(params.actions);
      
      var expectedUtility = expectation(
        Enumerate(function(){
          var state = buildState(manifestState, sample(updatedBelief));
          assert.ok(getManifestState(state, params) == manifestState, 'check on state');
          return expUtility(state, action, timeLeft, updatedBelief, params);   
        }));

      factor(params.alpha * expectedUtility);
      return {action: action, belief:updatedBelief};
    });
  });
  
  
  var expUtility = dp.cache(
    function(state, action, timeLeft, currentBelief, params){
      var u = utility(state, action, params);

      if (timeLeft - 1 == 0){
        return u;
      } else {                     
        return u + expectation( Enumerate(function(){
          var nextState = transition(state, action, params);
          var nextManifestState = getManifestState(nextState,params);
          var observation = observe(nextState,params);
          var out = sample(agent(nextManifestState, timeLeft-1, currentBelief, observation, params));
          var nextAction = out.action;
          var nextBelief = out.belief;
          return expUtility(nextState, nextAction, timeLeft-1, nextBelief, params);
        }));
      }                      
    });
  

  var simulate = function(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples){
    assert.ok(  actualTotalTime <= perceivedTotalTime  &  _.isString(startState.manifestState), 'simulate args');
    
    var sampleSequence = function(state, actualTimeLeft, perceivedTimeLeft, history, currentBelief, observation){
      assert.ok( actualTimeLeft>=0  & perceivedTimeLeft>=0 & isERP(currentBelief)  & _.isArray(history), 'samp sequence args');
      
      if (actualTimeLeft==0){
        return history.slice(0,history.length-1);
      } else {
        
        var out = sample(agent( getManifestState(state, params), perceivedTimeLeft, currentBelief, observation, params));
        var action = out.action;
        var updatedBelief = out.belief;
        var nextState = transition(state, action, params);
        var nextObservation = observe(nextState, params);
        var nextHistory = push(history, nextState);
          // for testing:
	  // var nextHistory = push(history, [action, expUtility(state, action, perceivedTimeLeft, currentBelief, params),
	  // 				   nextState]);
	  
        return sampleSequence(nextState, actualTimeLeft-1, perceivedTimeLeft-1, nextHistory, updatedBelief, nextObservation);
      }
    };
    
    var N = numberRejectionSamples;
    var InferFunction = (N==0) ? Enumerate : function(f){return Rejection(f,N, undefined, true);};
    
    return InferFunction(function(){
      var startHistory = [startState];
      var observation = observe(startState, params);
      var latentStatePrior = params.latentStatePrior;
      return sampleSequence(startState, actualTotalTime, perceivedTotalTime, startHistory, latentStatePrior, observation);
      
    });                 
  };
    
  return simulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples);
};




// BANDIT TEST PROBLEM
// Trivial deterministic 2-arm bandits

// Start in manifestState 'start'. Choose actions 'A' or 'B' which
// take agent to manifestStates 'A' or 'B' (deterministically) and yield
// a utility and an observation of that utility. Then repeat
// for the number of trials (you can never return to 'start').

// States have form {manifestState:'A', latentState:{A:1, B:0} }
// where the latenState is the utility table for the manifestStates.

// Since we assume the agent knows the utility of A, the agent
// gets "noObservation" observation in that state, and this
// can be filtered out to avoid pointless computation of an ERP. 


var getBanditParams = function(uA, priorB, alpha){

  // start in special 'start' state which you can never return to
  var latentStatePriorERP = Enumerate(function(){return {'A':uA, 'B':priorB()};});
  
  var startStatePrior = function(){
    return {manifestState:'start', 
            latentState: sample(latentStatePriorERP)
           };
  };

  var states = ['start','A','B'];
  var actions = ['A','B'];
  
  var transition = function(state, action){
    return update(state, {manifestState: action});
  };

  var utility = function(state,action){
    if (state.manifestState=='start'){return 0;}
    return state.latentState[state.manifestState];
  };

  var observe = function(state){
    var manifestState = state.manifestState;

    return manifestState=='A' || manifestState=='start' ? 
      'noObservation': state.latentState[manifestState];
  };

  // could use *_.isEqual* for deep object equality
  var observationEquality = function(obs1,obs2){return stringify(obs1)===stringify(obs2);};

  var getManifestState = function(state){return state.manifestState;};
  
  return {deterministicObservations: true,
          alpha: alpha,
          states: states,
          actions: actions,
          utility: utility,
          transition: transition, 
          observe: observe,
          observationEquality: observationEquality,
          startStatePrior: startStatePrior,
          latentStatePrior: latentStatePriorERP,
          getManifestState: getManifestState,
          uA: uA
         };
};





// Correctness and speed tests for agent on 2-arm deterministic bandits
// Use either *pomdpSimulate* or *updatePOMDPSimulate*

var testBandits = function(pomdpSimulateVersion){

  // helper function
  var historyToArms = function(history){
    return map( function(state){return state.manifestState;}, history.slice(1,history.length) );
  };
  
  // main function for running agent on bandit problem
  var runBanditTest = function(numTrials, uA, priorB, startState, numberRejectionSamples){
    var perceivedTotalTime = numTrials;
    var actualTotalTime = perceivedTotalTime;
    var alpha = 50; // FIXED LOW NOISE
    var params = getBanditParams( uA, priorB, alpha);
    var out = pomdpSimulateVersion(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples);
    return historyToArms(out.MAP().val);
  };

  var numberRejectionSamples = 0; // ---- use Enumerate instead of Rejection
  
  // one trial, so take A
  var numTrials = 2;
  var uA = 0.05;
  var priorB = function(){return categorical([.97, .03], [0,1])};
  var startState = {manifestState:'start', latentState: {A:uA, B:0}};
  assert.ok( arraysEqual(['A'], runBanditTest(numTrials, uA, priorB, startState, numberRejectionSamples)), 'testbandits1');
  
  
  // three trials, so try B
  var numTrials = 4;
  var uA = 0.05;
  var priorB = function(){return categorical([.97, .03], [0,10])};
  var startState = {manifestState:'start', latentState: {A:uA, B:0}};
  assert.ok( arraysEqual(['B','A','A'], runBanditTest(numTrials, uA, priorB, startState, numberRejectionSamples)), 'testbandits2');
  console.log('passed first two');
  
  // three trials, so try B and stick
  var numTrials = 4;
  var uA = 0.05;
  var priorB = function(){return categorical([.97, .03], [0,10])};
  var startState = {manifestState:'start', latentState: {A:uA, B:10}};
  assert.ok( arraysEqual(['B','B','B'], runBanditTest(numTrials, uA, priorB, startState, numberRejectionSamples)), 'testbandits3');

    console.log('passed third');
    
  // single trial, but EU for B is high
  var numTrials = 2;
  var uA = 0.05;
  var priorB = function(){return categorical([.97, .03], [0,100])};
  var startState = {manifestState:'start', latentState: {A:uA, B:100}};
    assert.ok( arraysEqual(['B'], runBanditTest(numTrials, uA, priorB, startState, numberRejectionSamples)), 'testbandits4');

    console.log('passed fourth');

  // three trials, EU for B is low so don't try
    var numTrials = 4;
    var uA = 0.05;
    var priorB = function(){return categorical([0.97, 0.03], [0, 0.4]);};
    var startState = {manifestState: 'start', latentState: {A: uA, B: 0.4}};
    assert.ok( arraysEqual(['A', 'A', 'A'], runBanditTest(numTrials, uA, priorB, startState, numberRejectionSamples)), 'testbandits5');

  console.log('\n\n passed 2 armed bandit correctness tests');

  // speed test: rejection vs. enumerate

  var speedTest = function(numberRejectionSamples, numTrialsAr){
    map( function(numTrials){
      var uA = .4;
      var priorB = function(){return categorical([.97, .01], [0,10])};
      var startState = {manifestState:'start', latentState: {A:uA, B:10}};
      var runThunk = function(){return  runBanditTest(numTrials, uA, priorB, startState, numberRejectionSamples);};
      var out = timeit(runThunk);
      assert.ok( 'B' == out.value[0], 'bandit speed test' );
      return out.runtimeInMilliseconds;
    }, numTrialsAr);
  };

  var numTrialsArEnum = [8,9,10,11,12];
  var numberRejectionSamples = 0;
  console.log('\n\nBandit speed test for ENUMERATE.\n Number of trials', numTrialsArEnum, 
              ' \nruntime in ms: ', speedTest(numberRejectionSamples, numTrialsArEnum));

  var numTrialsArRej = [8,9,10,11,12, 13, 14, 15, 20];
  var numberRejectionSamples = 100;
  console.log('\n\nBandit speed test for REJECTION (100 samples).\n Number of trials',
              numTrialsArRej,' \nruntime in ms: ', speedTest(numberRejectionSamples, numTrialsArRej));

  console.log('\n\n passed 2-armed bandit tests');

  
};

// ----------------------------

// function for making parameters for a k-armed bandit. numArms is the number of arms.
// arms will be labelled '0' through 'k - 1'. u0 is the utility of the first arm (assumed
// to be known to the agent). priorArms is a function that samples from a prior over the
// utilities of the other arms, returning an object. alpha represents the softmax noise
// of the agent.
var getKArmBanditParams = function(numArms, u0, priorArms, alpha) {
    var latentStatePriorERP = Enumerate(function(){return update({'0': u0}, priorArms());});

    // similarly to getBanditParams, the initial state is a special 'start' state
    // that can never be returned to.
    var startStatePrior = function(){
	return {manifestState: 'start',
	        latentState: sample(latentStatePriorERP)};
    };

    var actions = map(stringify, range(numArms - 1));
    var states = cons('start', actions);

    var transition = function(state, action){
	return update(state, {manifestState: action});
    };

    var utility = function(state, action){
	if (state.manifestState == 'start') {
	    return 0;
	} else {
	    return state.latentState[state.manifestState];
	}
    };

    // observe gets you the utility of the state, unless the agent is in
    // 'start' or 0, in which case there is no observation.
    var observe = function(state){
	var manifestState = state.manifestState;
	return manifestState == 0 || manifestState == 'start' ?
	    'noObservation' : state.latentState[manifestState];
    };

    var observationEquality = function(obs1,obs2){return stringify(obs1)===stringify(obs2);};

    var getManifestState = function(state){return state.manifestState;};

    return {deterministicObservations: true,
            alpha: alpha,
            states: states,
            actions: actions,
            utility: utility,
            transition: transition, 
            observe: observe,
            observationEquality: observationEquality,
            startStatePrior: startStatePrior,
            latentStatePrior: latentStatePriorERP,
            getManifestState: getManifestState,
            u0: u0
           };
};

// correctness and speed tests for agent on k-armed deterministic bandits
// also written to use *pomdpSimulate* or *updatePOMDPsimulate*

var testKArmBandits = function(pomdpSimulateVersion){
    // helper function
    var historyToArms = function(history){
	return map( function(state){return state.manifestState;}, history.slice(1,history.length) );
    };
    
    // main function for running agent on bandit problem
    var runBanditTest = function(numTrials, numArms, u0, priorArms, startState, numberRejectionSamples){
	var perceivedTotalTime = numTrials;
	var actualTotalTime = perceivedTotalTime;
	var alpha = 50; // FIXED LOW NOISE
	var params = getKArmBanditParams(numArms, u0, priorArms, alpha);
	var out = pomdpSimulateVersion(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples);
	return historyToArms(out.MAP().val);
    };

    var numberRejectionSamples = 0; // ---- use Enumerate instead of Rejection
    
    // check that k arm bandits behave the same way as two armed bandits when k = 2.
    var numArms = 2;
    
    var numTrials = 2;
    var u0 = 0.05;
    var priorArms = function(){return {'1': categorical([.97, .03], [0,1])};};
    var startState = {manifestState:'start', latentState: {'0': u0, '1': 0}};
    assert.ok( arraysEqual(['0'], runBanditTest(numTrials, numArms, u0, priorArms, startState,
    						numberRejectionSamples)), 'testKbandits1');
    
    
    // three trials, so try 1
    var numTrials = 4;
    var u0 = 0.05;
    var priorArms = function(){return {'1': categorical([.97, .03], [0,10])};};
    var startState = {manifestState:'start', latentState: {'0':u0, '1':0}};
    assert.ok( arraysEqual(['1','0','0'], runBanditTest(numTrials, numArms, u0, priorArms, startState,
    							numberRejectionSamples)), 'testKbandits2');
    console.log('passed first two');
    
    // three trials, so try 1 and stick
    var numTrials = 4;
    var u0 = 0.05;
    var priorArms = function(){return {'1': categorical([.97, .03], [0,10])};};
    var startState = {manifestState:'start', latentState: {'0':u0, '1':10}};
    assert.ok( arraysEqual(['1','1','1'], runBanditTest(numTrials, numArms, u0, priorArms, startState,
    							numberRejectionSamples)), 'testKbandits3');

    console.log('passed third');
    
    // single trial, but EU for 1 is high
    var numTrials = 2;
    var u0 = 0.05;
    var priorArms = function(){return {'1': categorical([.97, .03], [0,100])};};
    var startState = {manifestState:'start', latentState: {'0':u0, '1':100}};
    assert.ok( arraysEqual(['1'], runBanditTest(numTrials, numArms, u0, priorArms, startState,
    						numberRejectionSamples)), 'testKbandits4');

    console.log('passed fourth');

    // three trials, EU for 1 is low so don't try
    var numTrials = 4;
    var u0 = 0.05;
    var priorArms = function(){return {'1': categorical([0.97, 0.03], [0, 0.4])};};
    var startState = {manifestState: 'start', latentState: {'0': u0, '1': 0.4}};
    assert.ok( arraysEqual(['0', '0', '0'], runBanditTest(numTrials, numArms, u0, priorArms, startState,
    							  numberRejectionSamples)), 'testKbandits5');

    console.log('\n\n passed k = 2 tests');

    // now test the case when k = 3
    var numArms = 3;
    
    // three trials, explore 1, then 2, then stick with 0
    var numTrials = 4;
    var u0 = 0.05;
    var priorArms = function(){return {'1': categorical([0.97, 0.03], [0, 10]),
    				       '2': categorical([0.97, 0.03], [0, 5])};};
    var startState = {manifestState: 'start', latentState: {'0': u0, '1': 0, '2': 0}};
    assert.ok( arraysEqual(['1', '2', '0'], runBanditTest(numTrials, numArms, u0, priorArms, startState,
    							  numberRejectionSamples)), 'testKbandits6');

    // three trials, explore 1, then stick with 2
    var numTrials = 4;
    var u0 = 0.05;
    var priorArms = function(){return {'1': categorical([0.97, 0.03], [0, 10]),
    				       '2': categorical([0.97, 0.03], [0, 5])};};
    var startState = {manifestState: 'start', latentState: {'0': u0, '1': 0, '2': 5}};
    assert.ok( arraysEqual(['1', '2', '2'], runBanditTest(numTrials, numArms, u0, priorArms, startState,
    							  numberRejectionSamples)), 'testKbandits7');

    console.log('\n\n passed k = 3 tests');

    console.log('\n\n passed k armed bandit correctness tests');

    // speed test: rejection vs. enumerate

    var speedTest3 = function(numberRejectionSamples, numTrialsAr){
	map( function(numTrials){
	    var u0 = .05;
	    var priorArms = function(){return {'1': categorical([0.97, 0.03], [0, 10]),
					       '2': categorical([0.97, 0.03], [0, 5])};};
	    var startState = {manifestState: 'start', latentState: {'0': u0, '1': 0, '2': 0}};
	    var numArms = 3;
	    var runThunk = function(){return  runBanditTest(numTrials, numArms, u0, priorArms, startState,
							    numberRejectionSamples);};
	    var out = timeit(runThunk);
	    assert.ok( '1' == out.value[0], 'bandit speed test' );
	    return out.runtimeInMilliseconds;
	}, numTrialsAr);
    };

    var speedTest2 = function(numberRejectionSamples, numTrialsAr){
	map( function(numTrials){
	    var u0 = .05;
	    var priorArms = function(){return {'1': categorical([0.97, 0.03], [0, 10])};};
	    var startState = {manifestState: 'start', latentState: {'0': u0, '1': 0}};
	    var numArms = 2;
	    var runThunk = function(){return  runBanditTest(numTrials, numArms, u0, priorArms, startState,
							    numberRejectionSamples);};
	    var out = timeit(runThunk);
	    assert.ok( '1' == out.value[0], 'bandit speed test' );
	    return out.runtimeInMilliseconds;
	}, numTrialsAr);
    };

    var numTrialsArEnum2 = [8,9,10,11,12];
    var numberRejectionSamples = 0;
    console.log('\n\nk=2 armed bandit speed test for ENUMERATE.\n Number of trials', numTrialsArEnum2, 
		' \nruntime in ms: ', speedTest2(numberRejectionSamples, numTrialsArEnum2));

    var numTrialsArRej2 = [8,9,10,11,12, 13, 14, 15, 20];
    var numberRejectionSamples = 100;
    console.log('\n\nk=2 armed bandit speed test for REJECTION (100 samples).\n Number of trials',
		numTrialsArRej2,' \nruntime in ms: ', speedTest2(numberRejectionSamples, numTrialsArRej2));


    var numTrialsArEnum3 = [5, 6, 7, 8, 9];
    var numberRejectionSamples = 0;
    console.log('\n\nK=3 armed bandit speed test for ENUMERATE.\n Number of trials',
		numTrialsArEnum3,' \nruntime in ms: ', speedTest3(numberRejectionSamples, numTrialsArEnum3));

    var numTrialsArRej3 = [5, 6, 7, 8, 9, 10, 15, 20];
    var numberRejectionSamples = 100;
    console.log('\n\nK=3 armed bandit speed test for REJECTION (100 samples).\n Number of trials',
		numTrialsArRej3,' \nruntime in ms: ', speedTest3(numberRejectionSamples, numTrialsArRej3));

    console.log('\n\n passed k armed bandit tests');

};

// ----------------------

// function that makes parameters for a gridworld pomdp where the latent state represents 
// which grid positions are terminal, and the manifest state is the stringified grid position the agent is in.
// a grid position is an array containing two numbers, the x- and y- coordinate of the position.
// The agent knows the utility of all grid positions that might be terminal,
// conditioned on them actually being terminal. If a grid position is not terminal, then it has no utility
// (except for the time cost of not being in a terminal grid position). The agent also knows which grid positions
// are blocked. The agent observes the utility of leaving the grid position that they are currently in.
// After leaving a terminal grid position, the agent enters a postTerminal state, whose manifest state is the
// string 'dead'.

// xLim and yLim refer to the size of the grid in the x and y directions. xLim and yLim must both be less than
// or equal to 10, so that all components of all grid positions are single digits.

// openGridPositions is an array of grid positions that are not blocked.

// startGridPosition is the grid position that the agent starts in. It is assumed not to be terminal.

// terminalPrior is a thunk which returns an array of grid positions which are terminal.

// utilityFunction is a function from grid positions to things that could be utilities. For grid positions that
// could possibly be terminal, utilityFunction returns the utility of that grid position if it were terminal.
// for grid positions that could not possibly be terminal, utilityFunction returns a constant time cost.
// if a state could possibly be terminal but is not, its utility will be the time cost.

// transitionNoiseProb is the probability of an action being changed to an action in the orthogonal direction.

// alpha governs the softmax noise of the agent.
var makeBlockedGridPOMDPParams = function(xLim, yLim, openGridPositions, startGridPosition, terminalPrior,
					  utilityFunction, transitionNoiseProb, alpha) {
    assert.ok(typeof(xLim) == 'number' && typeof(yLim) == 'number' && xLim >= 1 && yLim >= 1,
	      'xLim or yLim wrong in makeBlockedGridPOMDPParams arguments');
    assert.ok(xLim <= 10 && yLim <= 10,
	      'xLim or yLim too big in makeBlockedGridPOMDPParams arguments');
    assert.ok(typeof(openGridPositions[0][0]) == 'number' && typeof(openGridPositions[0][1]) == 'number',
	      'openGridPositions wrong in makeBlockedGridPOMDPParams arguments');
    assert.ok(typeof(startGridPosition[0]) == 'number' && typeof(startGridPosition[1]) == 'number',
	      'startGridPosition wrong in makeBlockedGridPOMDPParams arguments');
    assert.ok(typeof(transitionNoiseProb) == 'number',
	      'transitionNoiseProb wrong in makeBlockedGridPOMDPParams arguments');
    assert.ok(typeof(alpha) == 'number',
	      'alpha wrong in makeBlockedGridPOMDPParams arguments');


    var startStatePrior = function(){
	return {manifestState: stringify(startGridPosition),
		latentState: map(stringify, terminalPrior())};
    };

    var latentStatePriorERP = Enumerate(function(){return map(stringify, terminalPrior());});

    var actions = ['l', 'r', 'u', 'd'];

    // only works for states that are not postTerminal
    var manifestStateToGridPosition = function(state) {
	assert.ok(typeof(state) == 'string', 'manStateToGridPos arg');
	var x = global.Number(stringChar(state, 1));
	var y = global.Number(stringChar(state, 3));
	return [x,y];
    };

    // only works for states that are not postTerminal
    var isTerminal = function(state) {
	assert.ok(typeof(state.manifestState) == 'string', 'isTerminal manifest state not string');
	assert.ok(typeof(state.latentState[0]) == 'string', 'isTerminal latent state not string array');
	// console.log('isTerminal', state.manifestState);
	// console.log('isTerminal', state.latentState[0]);
	var gridPos = manifestStateToGridPosition(state.manifestState);
	var terminals = map(manifestStateToGridPosition, state.latentState);
	return stateInArray(gridPos, terminals);
    };

    var isPostTerminal = function(state) {
	return state.manifestState==='dead';
    };
    
    var utility = function(state, action) {
	assert.ok(typeof(state.manifestState) == 'string', 'utility manifest state not string');
	// console.log('utility', state.manifestState);
	if (isPostTerminal(state)) {
	    return 0;
	} else if (isTerminal(state)) {
	    return utilityFunction(manifestStateToGridPosition(state.manifestState));
	} else {
	    return utilityFunction(startGridPosition);
	}
    };
    
    var makeDetGridTransition = function(xLim, yLim, openGridPositions, latentState){
	
	var isAllowedGridPos = function(gridPos) {
	    return (inGrid(xLim, yLim, gridPos) && stateInArray(gridPos, openGridPositions));
	};

	return function(state, action) {
	    assert.ok(typeof(state.manifestState) == 'string', 'det transition manifest state arg not string');
	    assert.ok(typeof(state.latentState[0]) == 'string', 'det transition latent state arg not array of strings');
	    if (isPostTerminal(state)) {return state;}
	    else {
		var gridPos = manifestStateToGridPosition(state.manifestState);
		assert.ok(isAllowedGridPos(gridPos),
			  'tried to transition but current grid position is not allowed');
		assert.ok(indexOf(action, actions) != undefined,
			  'tried to transition but action is not allowed');

		var gridTransition = {l: [gridPos[0]-1, gridPos[1]],
				      r: [gridPos[0]+1, gridPos[1]],
				      u: [gridPos[0], gridPos[1]+1],
				      d: [gridPos[0], gridPos[1]-1]};

		if (isTerminal(state)) {
		    return buildState('dead', state.latentState);
		} else {
		    var possibleNextGridPos = gridTransition[action];
		    return isAllowedGridPos(possibleNextGridPos) ? buildState(stringify(possibleNextGridPos),
									      state.latentState) : state;
		}
	    }
	};
    };

    var makeNoisyGridTransition = function(xLim, yLim, openGridPositions, latentState, transitionNoiseProb){
	var detTransition = makeDetGridTransition(xLim, yLim, openGridPositions, latentState);

	var noiseActionTable = {u: ['l','r'], d: ['l','r'], l: ['u','d'], r: ['u','d'] };

	return function(state, action) {
	    assert.ok(typeof(state.manifestState) == 'string', 'noisy transition manifest state arg not string');
	    assert.ok(typeof(state.latentState[0]) == 'string', 'noisy transition latent state arg not array of strings');
	    return flip(transitionNoiseProb) ? detTransition(state, uniformDraw(noiseActionTable[action])) : detTransition(state, action);
	};
    };
    
    var transition = function(state, action) {
	assert.ok(typeof(state.manifestState) == 'string', 'transition manifest state arg not string');
	assert.ok(typeof(state.latentState[0]) == 'string', 'transition latent state arg not array of strings');
	// console.log('transition', state.manifestState);
	// console.log('transition', state.latentState[0]);
	if (transitionNoiseProb === 0) {
	    return makeDetGridTransition(xLim, yLim, openGridPositions, state.latentState)(state, action);
	} else {
	    return makeNoisyGridTransition(xLim, yLim, openGridPositions, state.latentState,
					   transitionNoiseProb)(state, action);
	}
    };

    var observe = function(state) {
	return utility(state, 'l');
    };

    var observationEquality = function(obs1,obs2){return stringify(obs1)===stringify(obs2);};

    var getManifestState = function(state){return state.manifestState;};

    return {deterministicObservations: true,
	    alpha: alpha,
	    actions: actions,
	    utility: utility,
	    transition: transition,
	    observe: observe,
	    observationEquality: observationEquality,
	    startStatePrior: startStatePrior,
	    latentStatePrior: latentStatePriorERP,
	    getManifestState: getManifestState
	   };
};

// everything in the support of terminalPrior must be a sub-array of [[0,0], [1,4], [3,6], [4,2]]
// utilityTable is a table like {donutSouth: 3, donutNorth: 2, veg: 5, noodle: 1, timeCost: -0.2}
var makeSmallDonutParams = function(utilityTable, alpha, transitionNoiseProb, terminalPrior) {
    assert.ok( typeof(utilityTable.veg) == 'number' && typeof(utilityTable.timeCost) == 'number'
	       && typeof(alpha) == 'number' &&  alpha >= 0 && typeof(transitionNoiseProb) == 'number'
	       && transitionNoiseProb >= 0, 'makeSmallDonutParams args');

    var openGridPositions = [ [0,0], [0,1],
			      [1,1], [1,4],
			      [2,0], [2,1], [2,2], [2,3], [2,4], [2,5],
			      [3,3], [3,5], [3,6],
			      [4,2], [4,3], [4,4], [4,5] ];
    var xLim = 5;
    var yLim = 7;
    var startGridPosition = [2,1];
    var gridPosToRestaurantTable = { '[0,0]': 'donutSouth',
                                     '[1,4]': 'donutNorth', 
                                     '[3,6]': 'veg',
                                     '[4,2]': 'noodle' };

    var gridPosToRestaurant = function(gridPos) {
	return gridPosToRestaurantTable[stringify(gridPos)] ? gridPosToRestaurantTable[stringify(gridPos)] : false;
    };

    var utilityFunction = function(gridPos) {
	if (gridPosToRestaurant(gridPos)) {
	    return utilityTable[gridPosToRestaurant(gridPos)];
	} else {
	    return utilityTable['timeCost'];
	}
    };

    return makeBlockedGridPOMDPParams(xLim, yLim, openGridPositions, startGridPosition, terminalPrior,
				      utilityFunction, transitionNoiseProb, alpha);
};


// 2x2 grid, possible terminals are [0,1] and [1,0]
var makeMiniGridParams = function(utilityFunction, alpha, transitionNoiseProb, terminalPrior) {
    var xLim = 2;
    var yLim = 2;
    var openGridPositions = [[0,0], [0,1], [1,0], [1,1]];
    var startGridPosition = [0,0];
    return makeBlockedGridPOMDPParams(xLim, yLim, openGridPositions, startGridPosition, terminalPrior,
				      utilityFunction, transitionNoiseProb, alpha);
};

var testGridWorlds = function(pomdpSimulateVersion) {
    // helper function
    var historyToGridPoses = function(history){
	return map( function(state){return state.manifestState;}, history.slice(1,history.length) );
    };

    var runMiniTest = function(startLatentState, utilityFunction, terminalPrior, numberRejectionSamples) {
	var perceivedTotalTime = 5;
	var actualTotalTime = 5;
	var alpha = 50;
	var params = makeMiniGridParams(utilityFunction, alpha, 0, terminalPrior);
	var startManifestState = '[0,0]';
	var startState = buildState(startManifestState, startLatentState);
	var out = pomdpSimulateVersion(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples);
	return historyToGridPoses(out.MAP().val);
    };

    var numberRejectionSamples = 0;

    var miniUtilityFunction = function(gridPos) {
	if (stringify(gridPos) == stringify([0,1])) {
	    return 200;
	} else if (stringify(gridPos) == stringify([1,0])) {
	    return 1;
	} else {
	    return -0.1;
	}
    };

    var miniTerminalUnevenPrior = function(p){return function(){
	if (flip(p)) {
	    return [[0,1],[1,0]];
	} else {
	    return [[1,0]];
	}};
    };

    var miniTerminalEvenPrior = function(p) {return function(){
	if (flip(p)) {
	    return [[0,1]];
	} else {
	    return [[1,0]];
	}};
    };
    
    // with miniTerminalEvenPrior, just go to the most likely terminal, since if you're wrong you aren't stuck
    var startLatentState1 = ["[0,1]"];
    assert.ok(arraysEqual(['[0,1]', 'dead', 'dead', 'dead'], runMiniTest(startLatentState1, miniUtilityFunction,
									  miniTerminalEvenPrior(0.7), numberRejectionSamples)),
	      'testMiniGrid1');
    var startLatentState2 = ["[1,0]"];
    assert.ok(arraysEqual(["[1,0]", "dead", "dead", "dead"], runMiniTest(startLatentState2, miniUtilityFunction,
									  miniTerminalEvenPrior(0.3), numberRejectionSamples)),
	      'testMiniGrid2');

    // with miniTerminalUnevenPrior, go up even if it's unlikely to be terminal, since if you go right you're definitely stuck
    var startLatentState3 = ["[0,1]", "[1,0]"];
    assert.ok(arraysEqual(["[0,1]", "dead", "dead", "dead"], runMiniTest(startLatentState3, miniUtilityFunction,
									  miniTerminalUnevenPrior(0.1), numberRejectionSamples)),
	      'testMiniGrid3');

    // make sure that the agent makes the same first decision regardless of the latent state
    var startLatentState4 = ["[1,0]"];
    assert.ok(arraysEqual(runMiniTest(startLatentState3, miniUtilityFunction, miniTerminalUnevenPrior(0.1), numberRejectionSamples)[0],
			  runMiniTest(startLatentState4, miniUtilityFunction, miniTerminalUnevenPrior(0.1), numberRejectionSamples)[0]),
	      'testMiniGrid4');

    console.log('\npassed all minigrid tests');

    var runDonutTest = function(actualTotalTime, startManifestState, startLatentState, utilityTable, terminalPrior) {
	var perceivedTotalTime = 7;
	var alpha = 50;
	var params = makeSmallDonutParams(utilityTable, alpha, 0, terminalPrior);
	var startState = buildState(startManifestState, startLatentState);
	// console.log(stringify(startState));
	var out = pomdpSimulateVersion(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples);
	return historyToGridPoses(out.MAP().val);
    };

    var restaurantToGridPosTable = { 'donutSouth': [0,0],
				     'donutNorth': [1,4], 
                                     'veg': [3,6],
                                     'noodle': [4,2] };
    
    var restaurantsToGridPoses = function(restaurantArray) {
	return map(function(restaurant){return restaurantToGridPosTable[restaurant];}, restaurantArray);
    };

    var noodleOpenPrior = function() {
	if (flip()) {
	    return restaurantsToGridPoses(['donutSouth', 'donutNorth', 'veg', 'noodle']);
	} else {
	    return restaurantsToGridPoses(['donutSouth', 'donutNorth', 'veg']);
	}
    };
    
    var noodleLovingUtility = {donutSouth: 1,
			       donutNorth: 1,
			       veg: 2,
			       noodle: 3,
			       timeCost: -0.05};

    // if you like noodles, check noodle place out, if it's closed, go to veg
    var startLatentStateD1 = map(stringify, restaurantsToGridPoses(['donutSouth', 'donutNorth', 'veg']));
    assert.ok(arraysEqual(runDonutTest(4, '[4,3]', startLatentStateD1, noodleLovingUtility, noodleOpenPrior),
			  ['[4,2]','[4,3]','[4,4]']),
	      'testDonut1');

    var allOpenPrior = function(){
	return restaurantsToGridPoses(['donutSouth', 'donutNorth', 'veg', 'noodle']);
    };

    var donutClosedPrior = function(){
	return restaurantsToGridPoses(['veg', 'noodle']);
    };
    
    // if you don't like donuts, it doesn't matter if they're open or closed
    var startLatentStateD2 = map(stringify, restaurantsToGridPoses(['donutSouth', 'donutNorth', 'veg', 'noodle']));
    var startLatentStateD3 = map(stringify, restaurantsToGridPoses(['veg', 'noodle']));
    assert.ok(arraysEqual(runDonutTest(4, '[4,3]', startLatentStateD2, noodleLovingUtility, allOpenPrior),
			  runDonutTest(4, '[4,3]', startLatentStateD3, noodleLovingUtility, donutClosedPrior)),
	      'testDonut2');

    console.log('\npassed all donut tests');

};

console.log('testing gridworlds');
testGridWorlds(pomdpSimulate);
console.log('\n-------------\n Done with pomdpSimulate. Now doing updatePOMDPSimulate \n------------');
testGridWorlds(updatePOMDPSimulate);

ash();

console.log('testing 2 armed bandits');
testBandits(pomdpSimulate);
console.log('\n-------------\n Done with pomdpSimulate. Now doing updatePOMDPSimulate \n------------');
testBandits(updatePOMDPSimulate);
console.log('\n-------------\n testing k armed bandits \n-------------');
testKArmBandits(pomdpSimulate);
console.log('\n-------------\n Done with pomdpSimulate. Now doing updatePOMDPSimulate \n------------');
testKArmBandits(updatePOMDPSimulate);

ash();













// // K arm bandits
// var getKBanditParams = function(numArms, startBeliefState, totalNumActions, u0, categoricalPriorU, mdpAgent, numberRejectionSamples ){
//   assert.ok( (numArms > 1) & (totalNumActions > 0) & (typeof(u0)=='number') & 
//              (categoricalPriorU[0].length == categoricalPriorU[1].length & numberRejectionSamples >= 0), 'args for getkbanditparams');

//   var states = ['A'].concat(range(numArms));
//   assert.ok( startBeliefState.stateToUtilities.length == states.length-1, 'getkbandits states and utilities');

  
//   // variable params
//   var alpha = 200; 

//   // identical, independent priors on arms 1,...,k-1
//   var startBeliefStatePrior = function(){
//     var priorThunk = function(){return categorical(categoricalPriorU[0], categoricalPriorU[1]);};
//     return {state:'A',
//             stateToUtilities: [u0].concat( repeat(numArms-1, priorThunk) )};
//   }; 

//   // true state is in support of agent's prior
//   var erpPrior = Enumerate(function(){return startBeliefStatePrior().stateToUtilities;});
//   assert.ok( Math.exp(erpPrior.score([],startBeliefState.stateToUtilities)) > 0, 'getkbandit erpPrior' )

  
//   // environment functions
//   var stateToActions = function(state){
//     return (state==='A') ? range(numArms) : ['A'];
//   };
  
//   var transition = function(state, action){
//     return update(state,{state:action});
//   };
  
//   var utility = function(state,action){ 
//     return state.state=='A' ? 0: state.stateToUtilities[state.state];
//   };

//   var observe = function(state){ // you observe true utility of state when you visit it
//     return ( state.state == 0 | state.state == 'A') ? 'no observation' : 
//       state.stateToUtilities[state.state];
//   };
  
//   var getState = function(state){return state.state;};

//   return {deterministicObservations: true,
//           totalNumActions: totalNumActions,
//           stateToActions: stateToActions, 
//           alpha: alpha,
//           states: states,
//           utility: utility,
//           transition: transition, 
//           observe: observe,
//           startBeliefStatePrior: startBeliefStatePrior,
//           categoricalPriorU: categoricalPriorU, // id purposes
//           startBeliefState: startBeliefState,
//           getState: getState,
//           u0: u0,
//           mdpAgent: mdpAgent,
//           numberRejectionSamples: numberRejectionSamples,
//           numArms: numArms
//          };
// };

// var runKBandit = function(params, actualTotalTime, perceivedTotalTime){
//   var erp =  simulate(agent, params.startBeliefState,  actualTotalTime, perceivedTotalTime, params);
//   var history = filter( function(state){return state != 'A';}, 
//                         map(function(state){return state.state;}, erp.MAP().val.history));
//   return simpleOutput ? erp.MAP().val : history;
// };


// var testKBandits = function(){
  
//   var runBanditTest = function(numArms, numTrials, u0, categoricalPriorU, startBeliefState, numberRejectionSamples){
//     var oneShot = false;
//     var mdpAgent = false;
//     var totalNumActions = 2 * numTrials; 
//     var perceivedTotalTime = totalNumActions;
//     var actualTotalTime = oneShot ? 2 : totalNumActions;
//     var banditParams = getKBanditParams(numArms, startBeliefState, totalNumActions, u0, categoricalPriorU, mdpAgent, numberRejectionSamples );
//     return runKBandit(banditParams, actualTotalTime, perceivedTotalTime);
//   };

//   // TWO ARM TESTS
//   var numberRejectionSamples = 0; // ---- use Enumerate instead of Rejection
//   var numArms = 2;
  
//   // one trial, so take A
//   var numTrials = 1;
//   var u0 = 0.05;
//   var categoricalPriorU = [[.97, .03], [0,1]];
//   var startBeliefState = {state:'A', stateToUtilities: [u0,0]};
//   assert.ok( arraysEqual([0], runBanditTest(numArms, numTrials, u0, categoricalPriorU, startBeliefState, numberRejectionSamples)), 'testkbandits1' );


//   // three trials, so try B
//   var numTrials = 3;
//   var u0 = 0.05;
//   var categoricalPriorU = [[.97, .03], [0,10]];
//   var startBeliefState = {state:'A', stateToUtilities: [u0,0]};
//   assert.ok( arraysEqual([1,0,0], runBanditTest(numArms, numTrials, u0, categoricalPriorU, startBeliefState, numberRejectionSamples)), 'testkbandits2' );

//   // three trials, so try B and stick
//   var numTrials = 3;
//   var u0 = 0.05;
//   var categoricalPriorU = [[.97, .03], [0,10]];
//   var startBeliefState = {state:'A', stateToUtilities: [u0,10]};
//   assert.ok( arraysEqual([1,1,1], runBanditTest(numArms, numTrials, u0, categoricalPriorU, startBeliefState, numberRejectionSamples)), 'testkbandits3' );

//   // >2 ARMS
//   var numArms = 3;
//   var numTrials = 3;
//   var u0 = 0.05;
//   var categoricalPriorU = [[.9, .1], [10,0] ]; // all other arms promising
//   var startBeliefState = {state:'A', stateToUtilities: [u0,0,0]};
//   var out = runBanditTest(numArms, numTrials, u0, categoricalPriorU, startBeliefState, numberRejectionSamples);
//   assert.ok( arraysEqual([1,2,0], out) | arraysEqual([2,1,0], out), 'testkbandits4');

//   var numArms = 3;
//   var numTrials = 4;
//   var u0 = 0.001;
//   var categoricalPriorU = [[.33, .33, .33], [0,1,2] ]; // all other arms promising
//   var startBeliefState = {state:'A', stateToUtilities: [u0,1,2]};
//   var out = runBanditTest(numArms, numTrials, u0, categoricalPriorU, startBeliefState, numberRejectionSamples);
//   assert.ok( arraysEqual([1,2,2,2], out) | arraysEqual([2,2,2,2], out), 'testkbandits5');


//   // speedtest for numArms
//   var speedTest = function(numberRejectionSamples, numTrialsAr){
//     map( function(numArms){
//       var numTrials = 6;
//       var u0 = .05;
//       var categoricalPriorU = [[.1, .9], [0,1]]; // thinks all other arms are u=1
      
//       var startBeliefState = {state:'A', stateToUtilities: [u0].concat( zeroes(numArms-1) ) };
//       var runThunk = function(){return runBanditTest(numArms, numTrials, u0, categoricalPriorU, startBeliefState, numberRejectionSamples);};
//       var out = timeit(runThunk);
//       // test whether all arms explored before going back to known 0-th arm
//       assert.ok( arraysEqual(  sort(out.value), zeroes(numTrials-numArms).concat(range(numArms))), 'kbandit speed')
//       return out.runtimeInMilliseconds;
//     }, numArmsList);
//   };

//   var numArmsList = [2, 3, 4, 5];
//   var numberRejectionSamples = 600;
//   console.log('\n\nBandit speed test for ENUMERATE.\n Number of trials', numArmsList,
//               ' \nruntime in ms: ', speedTest(numberRejectionSamples, numArmsList));

//   console.log('passed k bandit tests');

// };
// testKBandits();
// ash()
