// test to show the scaling properties of stochastic bandits

var varyTime = function(n) {

  var world = makeStochasticBanditWorld(2);

  var probablyChampagneERP = categoricalERP([0.2, 0.8], ['nothing', 'champagne']);

  var probablyNothingERP = categoricalERP([0.8, 0.2], ['nothing', 'champagne']);

  var startState = {manifestState: {loc: 'start',
				    timeLeft: n,
				    terminateAfterAction: false},
		    latentState: {0: deltaERP('chocolate'),
				  1: probablyChampagneERP}};

  var prior = Enumerate(function(){
    var manifestState = startState.manifestState;
    var latentState = {0: deltaERP('chocolate'),
		       1: uniformDraw([probablyNothingERP,
				       probablyChampagneERP])};
    return buildState(manifestState, latentState);
  });

  var prizeToUtility = {start: 0,
			nothing: 0,
			chocolate: 1,
			champagne: 1.5};

  var utility = function(state,action){
    var loc = state.manifestState.loc;
    return prizeToUtility[loc];
  };

  var agentParams = {utility: utility,
		     alpha: 10000,
		     priorBelief: prior,
		     fastUpdateBelief: false};

  var agent = makeBeliefAgent(agentParams, world);

  var displayTrajectory = function(trajectory) {
    var getLocAction = function(stateAction) {
      var state = stateAction[0];
      var action = stateAction[1];
      return [state.manifestState.loc, action];
    };

    var locsActions = map(getLocAction, trajectory);
    var flatLocsActions = _.flatten(locsActions);
    return flatLocsActions.slice(1, flatLocsActions.length - 1);
  };

  var f = function() {
    var trajectory = simulateBeliefAgent(startState, world, agent, 'stateAction');
    return displayTrajectory(trajectory);
  };

  return [n, timeit(f).runtimeInMilliseconds];
};

// console.log('Varying the lifetime of the agent (output of form [lifetime, runtime in milliseconds]):\n');
// console.log(map(varyTime, _.range(19).slice(2)));

var varyArms = function(n) {
  console.log(n);
  var world = makeStochasticBanditWorld(n);

  var probablyChampagneERP = categoricalERP([0.2, 0.8], ['nothing', 'champagne']);

  var probablyNothingERP = categoricalERP([0.8, 0.2], ['nothing', 'champagne']);
  
  var makeLatentState = function(numArms) {
    return map(function(x){return probablyChampagneERP;}, _.range(numArms));
  };

  var startState = {manifestState: {loc: 'start',
				    timeLeft: 5,
				    terminateAfterAction: false},
		    latentState: makeLatentState(n)};

  var latentSampler = function(numArms) {
    return map(function(x){return uniformDraw([probablyNothingERP,
					       probablyChampagneERP]);},
	       _.range(numArms));
  };

  var prior = Enumerate(function(){
    var manifestState = startState.manifestState;
    var latentState = latentSampler(n);
    return buildState(manifestState, latentState);
  });

  var prizeToUtility = {start: 0,
			nothing: 0,
			chocolate: 1,
			champagne: 1.5};

  var utility = function(state,action){
    var loc = state.manifestState.loc;
    return prizeToUtility[loc];
  };

  var agentParams = {utility: utility,
		     alpha: 10000,
		     priorBelief: prior,
		     fastUpdateBelief: false};

  var agent = makeBeliefAgent(agentParams, world);
  
  var displayTrajectory = function(trajectory) {
    var getLocAction = function(stateAction) {
      var state = stateAction[0];
      var action = stateAction[1];
      return [state.manifestState.loc, action];
    };

    var locsActions = map(getLocAction, trajectory);
    var flatLocsActions = _.flatten(locsActions);
    return flatLocsActions.slice(1, flatLocsActions.length - 1);
  };

  // // for testing
  // var trajectory = simulateBeliefAgent(startState, world, agent, 'stateAction');
  
  var f = function() {
    var trajectory = simulateBeliefAgent(startState, world, agent, 'stateAction');
    return displayTrajectory(trajectory);
  };

  return [n, timeit(f).runtimeInMilliseconds];

};

console.log('Varying the number of arms (output of form [num arms, runtime in milliseconds]):\n');
console.log(map(varyArms, [1,2,3]));
// note the increase in order of magnitude. If we called this for 4 arms, the
// increase would continue, meaning that it would take ages.
