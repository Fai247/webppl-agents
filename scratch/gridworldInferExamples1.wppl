var gridworldMDP = makeDonutWorld2({big: true});
var gridworldPOMDP = makeGridworldPOMDP(gridworldMDP);
var feature = gridworldMDP.feature;

var donutUtilityTable = {'Donut N': 5,
			 'Donut S': 5,
			 'Veg': 1,
			 'Noodle': 1,
			 timeCost: -0.1};
 
var vegUtilityTable = {'Donut N': 1,
		       'Donut S': 1,
		       Veg: 3,
		       Noodle: 1,
		       timeCost: -0.1};

var tableToUtilityFunction = function(table) {
  return function(state, action) {
    var stateFeatureName = feature(state.manifestState).name;
    if (stateFeatureName) {
      return table[stateFeatureName];
    } else {
      return table.timeCost;
    }
  };
};

var uninformedPrior = Enumerate(function(){
  if (flip(0.8)) {
    return {'Donut N': true,
	    'Donut S': false,
	    'Veg': true,
	    'Noodle': true};
  } else {
    return {'Donut N': true,
	    'Donut S': true,
	    'Veg': true,
	    'Noodle': true};
  }
});

var informedPrior = deltaERP({'Donut N': true,
			      'Donut S': true,
			      'Veg': true,
			      'Noodle': true});

var startState = {manifestState: {loc: [3,1],
				  dead: false,
				  timeLeft: 10,
				  digest: 1},
		  latentState: {'Donut N': true,
				'Donut S': true,
				'Veg': true,
				'Noodle': true}};

var agent = makeBeliefAgent({utility: tableToUtilityFunction(donutUtilityTable),
			     alpha: 100,
			     priorBelief: uninformedPrior}, gridworldPOMDP);

var observedTrajectory = simulateBeliefAgent(startState, gridworldPOMDP, agent, 6,
					     'states');
var observedTrajectories = [observedTrajectory];

var utilityParamsPrior = Enumerate(function(){
  if (flip(0.5)) {
    return donutUtilityTable;
  } else {
    return vegUtilityTable;
  }
});

var beliefPrior = Enumerate(function(){
  if (flip(0.5)) {
    return uninformedPrior;
  } else {
    return informedPrior;
  }
});

var alphaPrior = deltaERP(100);

var inferBeliefAgent = function(observedTrajectories, utilityParamsPrior, beliefPrior,
				alphaPrior, paramsToUtilityFunction, world) {

  var numTrajectories = observedTrajectories.length;
  var transition = world.transition;
  var observe = world.observe;

  var sampleAlongTrajectory = function(state, currentBelief, actionsSampled,
				       trajectory, agentActionBelief) {
    assert.ok(isERP(agentActionBelief(state.manifestState, currentBelief,
				      observe(state))),
	      'agentActionBelief not correct in sampleAlongTrajectory');
    
    if (actionsSampled === trajectory.length - 1) {
      return [];
    } else {
      var actionBeliefERP = agentActionBelief(state.manifestState, currentBelief,
					      observe(state));
      var nextStateERP = Enumerate(function(){
	return transition(state, sample(actionBeliefERP).action);
      });
      var newBelief = sample(actionBeliefERP).belief;

      var trajectoryNextState = trajectory[actionsSampled + 1];
      
      factor(nextStateERP.score([], trajectoryNextState));
      
      return sampleAlongTrajectory(trajectoryNextState, newBelief, actionsSampled + 1,
				   trajectory, agentActionBelief);
    }
  };

  return Enumerate(function(){
    var utilityParams = sample(utilityParamsPrior);
    var utility = paramsToUtilityFunction(utilityParams);
    var agentPrior = sample(beliefPrior);
    var alpha = sample(alphaPrior);
    var agent = makeBeliefAgent({utility: utility,
				 alpha: alpha,
				 priorBelief: agentPrior},
			       world);
    var agentActionBelief = agent.agent;

    var factorTrajectory = function(trajectory) {
      return sampleAlongTrajectory(trajectory[0], agentPrior, 0, trajectory,
				   agentActionBelief);
    };

    map(factorTrajectory, observedTrajectories);

    return {utilityParams: utilityParams,
	    prior: agentPrior,
	    alpha: alpha};
  });
};

var agentPosterior = inferBeliefAgent(observedTrajectories, utilityParamsPrior,
				      beliefPrior, alphaPrior, tableToUtilityFunction,
				      gridworldPOMDP);

printERP(agentPosterior);
