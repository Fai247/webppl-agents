// currently not functional

var printOut = function ( trajectory ) {
  console.log('trajectory', map( function (state) {return state.manifestState.loc;},
				 trajectory) );
  //console.log('expUtilities', out.startEU);
};


// second inference function: generate an agent. In the first state of the trajectory,
// update that agent's beliefs, get the agent's ERP over next states, get the score
// of the actual next state, then put the agent in the actual next state, and repeat
// this process for the whole trajectory.

// same args as before
var inferUtilityBeliefBandits2 = function(observedTrajectory, utilitySignPrior,
					  beliefPrior, alpha, world) {
  var trajectoryLength = observedTrajectory.length;
  var perceivedTotalTime = observedTrajectory[0].manifestState.timeLeft;
  
  var rewardUtility = function(state, action) {
    return state.latentState[state.manifestState.loc];
  };

  return Enumerate(function(){
    var agentUtilitySign = sample(utilitySignPrior);
    var agentUtility = function(state, action){
      return agentUtilitySign * rewardUtility(state, action);
    };
    var agentPrior = sample(beliefPrior);
    var agent = makeBeliefAgent({utility: agentUtility,
				 alpha: alpha,
				 priorBelief: agentPrior},
				world);
    
    var agentActionBelief = agent.agent;
    var transition = world.transition;
    var observe = world.observe;

    var sampleAlongTrajectory = function(state, currentBelief, actionsSampled) {
      if (actionsSampled === trajectoryLength - 1) {
	return [];
      } else {
	var actionERP = Enumerate(function(){
	  return sample(agentActionBelief(state.manifestState, currentBelief,
					  observe(state))).action;
	});

	var newBelief = sample(agentActionBelief(state.manifestState, currentBelief,
						 observe(state))).belief;

	var nextState = observedTrajectory[actionsSampled + 1];
	
	factor(actionERP.score([], nextState.manifestState.loc));
	
	return sampleAlongTrajectory(nextState, newBelief, actionsSampled + 1);
      }
    };

    sampleAlongTrajectory(observedTrajectory[0], agentPrior, 0);

    return {utilitySign: agentUtilitySign, prior: agentPrior};
  });
};

// third inference function: doing inference on an agent's utilities and beliefs
// in a gridworld. Inference works the same way as in *inferUtilityBeliefBandits2*.

// arguments: [fill in later]

// var inferGridworld = function(observedTrajectory, utilityTablePrior, beliefPrior,
// 			      alpha, world) {
//   var trajectoryLength = observedTrajectory.length;
//   var perceivedTotalTime = observedTrajectory[0].manifestState.timeLeft;

//   return Enumerate(function(){
//     var utilityTable = sample(utilityTablePrior);
//     var utility = function(state, action) {

//     };
//   });
// }
