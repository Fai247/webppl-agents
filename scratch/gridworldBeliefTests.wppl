
// Make big gridworld
var getBigWorld = function(){
  var gridworldMDP = makeDonutWorld2({big: true});
  var feature = gridworldMDP.feature;
  return update(makeGridworldPOMDP(gridworldMDP), {feature:feature});
};


var tableToUtilityFunction = function(table, feature) {  
  return function(state, action) {
    if (state.manifestState.terminateAfterAction) {
      return 0;
    }
    var stateFeatureName = feature(state.manifestState).name;
    if (stateFeatureName) {  
      return table[stateFeatureName];
    } else {
      return table.timeCost;
    }
  };
};


var baseParamsNoDiscount = {
  priorBelief: null,
  utility: null,
  alpha: 100,
  noDelays: true,
  discount: 0,
  sophisticatedOrNaive: 'sophisticated',
  myopia: {on: false, bound: 0},
  boundVOI: {on: false, bound: 0},
};




var inferGridWorld = function(world, startState, baseParams, trueAgentParams, prior, trajectoryOrOffPolicy, 
                              numRejectionSamples, beliefOrBeliefDelay){
  
  var worldObserve = world.observe;
  var observe = getFullObserve(worldObserve);
  var feature = world.feature;
  
  var makeAgent = getMakeAgentFunction(beliefOrBeliefDelay);
  var simulate = getSimulateFunction(beliefOrBeliefDelay);

  var priorUtilityTable = prior.priorUtilityTable
  var priorAgentPrior = prior.priorAgentPrior;

  assert.ok(isPOMDPState(startState) && isERP(priorUtilityTable) && isERP(priorAgentPrior), 'inferGridworld args');
  assert.ok(trajectoryOrOffPolicy == 'trajectory' || trajectoryOrOffPolicy=='offPolicy', 
            'trajectoryOrOffPolicy is not valid');
  
  assert.ok(_.isNumber(numRejectionSamples) && isPOMDPWorld(world), 'inferGridWorld args' );

  
  // get observations using trueAgentParams
  var agent = makeAgent(trueAgentParams, world);
  var observedStateAction = simulate(startState, world, agent, 'stateAction');
  assert.ok( isPOMDPState(observedStateAction[0][0]), 'fullstate in trajectory for inferGridWorld');
  
  
  return Enumerate(function(){
    var utilityTable = sample(priorUtilityTable);
    var utility = tableToUtilityFunction(utilityTable, feature);

    var priorBelief = sample(priorAgentPrior);
    
    var params = update(baseParams, {utility:utility, priorBelief: priorBelief});
    
    var agent = makeAgent(params, world);
    var agentAct = agent.act;
    var agentUpdateBelief = agent.updateBelief;

    // Factor on whole sampled trajectory (SLOW IF TRANSITIONS NOT DETERMINISTIC OR IF NUM SAMPLES HIGH)
    var factorOnTrajectory = function(){
      var trajectoryERP = Rejection( function(){
        return simulate(startState, world, agent, 'states')}, numRejectionSamples);
      factor(trajectoryERP.score([], map(first, observedStateAction)));
    };

    
    // Move agent through observed sequence 
    var factorSequenceOffPolicy = function(currentBelief, previousAction, timeIndex){
      if (timeIndex < observedStateAction.length) { 

        // Go to next world state and sample observation from that state
        var state = observedStateAction[timeIndex][0];
        var observation = observe(state);

        // Update agent's internal state and get action ERP
        var delay = 0;     
        var nextBelief = beliefOrBeliefDelay == 'belief' ?
            agentUpdateBelief(currentBelief, observation, previousAction) :
            agentUpdateBelief(currentBelief, observation, previousAction, delay);


        var nextActionERP = beliefOrBeliefDelay == 'belief' ? 
            agentAct(nextBelief) : agentAct(nextBelief, delay); 

        var observedAction = observedStateAction[timeIndex][1];
        factor(nextActionERP.score([], observedAction));

        // condition on next world state, passing through updated internal state
        factorSequenceOffPolicy(nextBelief, observedAction, timeIndex + 1);
      }
    };

    var doInfer = (trajectoryOrOffPolicy=='trajectory') ? factorOnTrajectory() : 
        factorSequenceOffPolicy(priorBelief,'noAction', 0);
    
    return {utilityTable: utilityTable,
	    priorBelief: priorBelief};
  });
};









// WORLD PARAMS
var world = getBigWorld();
var feature = world.feature;
var perceivedTotalTime = 10;
var startingLocation = [2,1];

// Possible latent states
var allOpenLatentState = {
  'Donut N': true, 'Donut S': true, 'Veg': true, 'Noodle': true
};
var onlyDonutSouthClosedLatentState = {
  'Donut N': true, 'Donut S': false, 'Veg': true, 'Noodle': true
};

var trueLatentState = allOpenLatentState;
var startState = buildState({loc: startingLocation,
		             terminateAfterAction: false,
		             timeLeft: perceivedTotalTime,
		             timeAtRestaurant: 1},
	                    trueLatentState);


// TRUE AGENT PARAMS
// Params for true agent: agent thinks Donut South closed w/ prob .8


// Possible utility functions (true agent has donutUtility)
var donutUtilityTable = {'Donut N': 5,
			 'Donut S': 5,
			 'Veg': 1,
			 'Noodle': 1,
			 'timeCost': -0.1};
 
var vegUtilityTable = {'Donut N': 1,
		       'Donut S': 1,
		       'Veg': 3,
		       'Noodle': 1,
		       'timeCost': -0.1};

var uninformedLatentStateSampler = function(){
  return flip(.8) ? onlyDonutSouthClosedLatentState : trueLatentState;
};

var truePriorBelief = getPriorBeliefGridworld( startState.manifestState, uninformedLatentStateSampler);


var trueAgentParams = update(baseParamsNoDiscount, 
                             {priorBelief: truePriorBelief,
                              utility: tableToUtilityFunction(donutUtilityTable, feature)});



// PRIOR FOR INFERENCE PARAMS

var alternativePriorBelief = getPriorBeliefGridworld( startState.manifestState, function(){return trueLatentState;});
var priorUtilityTable = function(){return uniformDraw([donutUtilityTable, vegUtilityTable]);};
var priorAgentPrior = function(){return uniformDraw([truePriorBelief, alternativePriorBelief]);};

var prior = {priorUtilityTable: Enumerate(priorUtilityTable),
             priorAgentPrior: Enumerate(priorAgentPrior)};


// Inference params
var trajectoryOrOffPolicy = 'trajectory';
var numRejectionSamples = 10;

var erp = inferGridWorld(world, startState, baseParamsNoDiscount, trueAgentParams, prior, trajectoryOrOffPolicy, 
                         numRejectionSamples, 'belief');
console.log('erp');
printERP(erp);
ash();
