var inferTrajUtilTimeCost = function(trajectory, perceivedTotalTime,
                                     utilityPrior) {
    return Enumerate(function(){
	var newUtilityTable = utilityPrior();
	var newParams = makeDonutInfer(true, newUtilityTable, 100, 0);

	var startState = trajectory[0][0];
	var stateArray = map(first, trajectory);   // returns the first element
	// of everything in the
	// trajectory, which is just
	// the array of states visited.
	var actionArray = map(second, trajectory); // similarly, this gets the
	// array of actions made

        var outputParams = {trajectoryNumRejectionSamples: 0,
			    erpOverStatesOrActions: 'actions',
			    conditionOnStates: stateArray};

	var actionERPs = mdpSimulate(startState, trajectory.length,
		                     perceivedTotalTime, newParams,
				     outputParams).stateActionERPs;
        var erpActionPairs = zip(actionERPs, actionArray);

	map(function(pair){factor(pair[0].score([], pair[1]))},
	    erpActionPairs);

	return {donutUtil: newUtilityTable['donutSouth'],
		vegUtil: newUtilityTable['veg'],
		noodleUtil: newUtilityTable['noodle'],
		timeCost: newUtilityTable['timeCost']};
    });
};

var superComplexUtilPrior = function() {
    var donutUtil = uniformDraw([1,2,3]);
    var vegUtil = uniformDraw([1,2,3]);
    var noodleUtil = uniformDraw([1,2,3]);
    var timeCost = uniformDraw([-0.1, -1]);
    return {'donutSouth': donutUtil,
    	    'donutNorth': donutUtil,
	    'veg': vegUtil,
	    'noodle': noodleUtil,
    	    'timeCost': timeCost};
};

var params = makeDonutInfer(true, {'donutSouth': 1, 'donutNorth': 1, 'veg': 1,
                                   'noodle': 1, 'timeCost': 1}, 100, 0);
var dsTraj = [[[2,1], 'l'], [[1,1], 'l']];
// GridWorld.draw(params, {trajectory: dsTraj});
printERP(inferTrajUtilTimeCost(dsTraj, 7, superComplexUtilPrior));
