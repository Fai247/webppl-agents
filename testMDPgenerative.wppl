// Run as: webppl test.wppl --require webppl-dp --require webbpl-timeit --require . 

// Examples and Tests:
// Examples of running agent on different gridworlds.
// Basic tests of overall agent perfomance and gridworld library. 

// use *runAllTests* to run unit and integration tests.


// BASIC EXAMPLE:
// Sample trajectories in the (4,3) grid
// with transition noise but no softmax noise.


// Output is array of trajectories of form [ state0, state1, ... , state5 ]
var sampleGrid43 = function(numberSamples){
  assert.ok(numberSamples >= 1, 'repeat in sampleGrid43 will fail without samples > 1');
  var noiseProb = .1;
  var alpha = 100;
  var actualTotalTime = 6;
  
  var params = make43(noiseProb, alpha);
  var numberRejectionSamples = 100;
  var output = 'states';
  var getExpUtilityValues = false;
  var out = mdpSimulate([0,0], actualTotalTime, actualTotalTime, params, numberRejectionSamples,
                        getExpUtilityValues, output);
  return repeat(numberSamples, function(){return map(function(pair){return pair[0];}, sample(out.erp));});
};


// Donut/Veg Cafe from AAAI paper

var testMakeDonutInfer = function(){
  var alpha = 100;   // LOW NOISE
  var noiseProb = 0;
  var actualTotalTime = 9;
  var perceivedTotalTime = 9;
  var numberRejectionSamples = 100;  
  
  var runDonut = function(smallVersion, utilityTable){
    var params = makeDonutInfer(smallVersion, utilityTable, alpha, noiseProb);
    var startState = params.defaultStartState;
    var out = mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples, 
                      true, 'both', undefined);
    var erp = out.erp;
    console.log('size: ', smallVersion, 'u table', utilityTable, '\n');
    GridWorld.zipToDisplayGrid( erp.MAP().val, params.xLim, params.yLim, true );
  };    
  // goes to veg despite distance
  runDonut(true, {'donutSouth': 1, 'donutNorth':1, 'veg':3, 'noodle':2, 'timeCost':-.1});
  runDonut(false, {'donutSouth': 1, 'donutNorth':1, 'veg':3, 'noodle':2, 'timeCost':-.1});

  // donutSouth because of timeCost
  runDonut(true, {'donutSouth': 1, 'donutNorth':1, 'veg':3, 'noodle':2, 'timeCost':-1});
  runDonut(false, {'donutSouth': 1, 'donutNorth':1, 'veg':3, 'noodle':2, 'timeCost':-1});

  // softmax noise leads to variable trajectory length
  var alpha = 5;
  var noiseProb = 0;
  var actualTotalTime = 10;
  var perceivedTotalTime = 10;
  var numberRejectionSamples = 100;  
  
  var runSoftmax = function(smallVersion, utilityTable){
    var params = makeDonutInfer(smallVersion, utilityTable, alpha, noiseProb);
    var startState = params.defaultStartState;
    var out = mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples, 
                          true, 'both', undefined);
    var erp = out.erp;
    var lengthERP = Enumerate( function(){return sample(erp).length;} );
    console.log('size: ', smallVersion, 'u table', utilityTable, '\n');
    printERP(lengthERP);
    GridWorld.zipToDisplayGrid( erp.MAP().val, params.xLim, params.yLim, true );
  };    
  runSoftmax(true, {'donutSouth': 1, 'donutNorth':1, 'veg':2, 'noodle':2, 'timeCost':-.3});
  runSoftmax(false, {'donutSouth': 1, 'donutNorth':1, 'veg':2, 'noodle':2, 'timeCost':-.3});

  
  // speed test for small grid - vary only perceivedTotalTime
  var alpha = 100;
  var noiseProb = 0;
  var actualTotalTime = 1;
  var numberRejectionSamples = 0;  
  
  var runSpeed = function(smallVersion, utilityTable, perceivedTotalTime){
    var params = makeDonutInfer(smallVersion, utilityTable, alpha, noiseProb);
    var startState = params.defaultStartState;
    return mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples, 
                      true, 'both', undefined).erp;
  };
  var utilityTable = {'donutSouth': 1, 'donutNorth':1, 'veg':3, 'noodle':2, 'timeCost':-.1};
  
  map( function(perceivedTotalTime){
    var out = timeit( function(){return runSpeed(true, utilityTable, perceivedTotalTime)});
    console.log('perceivedTime, runtime in ms: ', perceivedTotalTime, out.runtimeInMilliseconds);
  }, [6,7,8,9] );
  
};



// EXAMPLE AND TESTS OF MDP SOLVING WITH DIFFERENT OUTPUTS AND DISPLAYS
// Print the grid with *displayGrid*.
// Print agent trajectory with *zipToDisplayGrid*/
// Compute *expUtilityValues*, which are the expected utilities of
// the state-action pairs the agent chose on MAP sequence.
// Assert result for MAP sequence equals predictions. 

// Test on a 3x3 grid with no blocked cells and on Russell-Norvig (4,3) grid. 

var smallGridTest = function(){

  // clean up output for display
  var clean = function(ar){return map(function(pair){return pair[0][0] + JSON.stringify(pair[0][1]);},ar)};
  
  var runGrid = function(makeGrid, noiseProb, alpha, startState, actualTotalTime, numberRejectionSamples){
    var params = makeGrid(noiseProb, alpha);
    displayGrid(params);
    var perceivedTotalTime = actualTotalTime;
    var getExpUtilityValues = true;
    var output = 'both';
    var out = mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, numberRejectionSamples,
                          getExpUtilityValues, output);
    var outMAP = out.erp.MAP().val;
    console.log('\n\n DISPLAY MAP PATH OF STATE-ACTIONS')
    GridWorld.zipToDisplayGrid( outMAP, params.xLim, params.yLim, true );
    console.log('\n\n ExpUtility of state-actions pairs in MAP sequence of state-actions: \n ', 
                out.expUtilityValues, ' \n\n MAP sequence ', outMAP);
    console.log('\n\n Sample trajectories from Posterior', repeat( 8, function(){return clean(sample(out.erp));}) );
    return selectIndex(outMAP,0); // output MAP state sequence
  };

  console.log('\n Small grid, non-stochastic transition, alpha=10 \n------------');
  var makeGrid = makeSmall;
  var startState = [0,0];
  var mapStates = runGrid(makeGrid, 0, 5, startState, 6,0);
  assert.ok(gridEqual(last(mapStates), [2,2]), 'agent only reaches terminal on last state due to softmax');
  
  console.log('\n\n SMALL GRID 2: stochastic transitions, alpha=100 \n--------------');
  var mapStates = runGrid(makeGrid, 0.1, 100, startState, 5, 500);
  assert.ok(gridEqual(last(mapStates), [2,2]), 'agent is at terminal on final state');
  
  console.log('\n\n\n Russell-Norvig 4,3 grid, noise=.25, alpha=100 \n --------------');
  var mapStates = runGrid(make43, .25, 100, [0,0], 6, 500);
  assert.ok(gridEqual(mapStates[1], [0,1]), 'agent goes up with first action');

  console.log('\n All tests in *smallGridTest* passed');
};



// Unit tests for gridworld constructor functions

var testInGrid = function(){
  assert.ok(inGrid(4,4,[0,0]) & inGrid(4,4,[3,2]) & inGrid(4,4,[3,3]) & inGrid(2,2,[1,1]), 'ingrid' );
  assert.ok( !(inGrid(4,4,[1.5,0]) | inGrid(4,4, ['u',0]) | inGrid(4,4,[-1,0]) |
               inGrid(4,4, [1.5,10]) | inGrid(2,2,[2,0]) | inGrid(4,4,['1',0]) ), 'ingrid' )
  console.log('passed testInGrid');
};

var testTransition = function(){
  var t = makeGridTransition(4,4,[],[]);
  assert.ok(  gridEqual( t([0,0],'l'), [0,0]) & 
              gridEqual( t([0,0],'r'), [1,0]) &  
              gridEqual( t([0,0],'u'), [0,1]), 'testTransition1' );
  
  var t = makeGridTransition(4, 4, [ [1,0], [1,1], [3,3] ],[]);

  assert.ok(  gridEqual( t([0,0],'l'), [0,0]) &
              gridEqual( t([0,0],'r'), [0,0]) & 
              gridEqual( t([0,0],'u'), [0,1]) & 
              gridEqual( t([0,1],'r'), [0,1]) &
              gridEqual( t([1,2],'d'), [1,2]) &
              gridEqual( t([2,3],'r'), [2,3]) &
              gridEqual( t([3,2],'u'), [3,2]), 'testTransition2'); 
  var t = makeStochasticGridTransition(4, 4, [ [1,0], [1,1], [3,3] ], .000000001, []);
  assert.ok(  gridEqual( t([0,0],'l'), [0,0]) &
              gridEqual( t([0,0],'r'), [0,0]) & 
              gridEqual( t([0,0],'u'), [0,1]) & 
              gridEqual( t([0,1],'r'), [0,1]) &
              gridEqual( t([1,2],'d'), [1,2]) &
              gridEqual( t([2,3],'r'), [2,3]) &
              gridEqual( t([3,2],'u'), [3,2]), 'testTransition3');

  
  var t = makeStochasticGridTransition(4, 4, [ ], .5, []);
  var thunk = function(){return t([1,1],'u');};
  var erp = Enumerate( thunk );
  assert.ok( gridEqual( erp.MAP().val, [1,2] ) )
  assert.ok( filter(function(pair){return gridEqual([0,1],pair);}, repeat(1000, thunk) ), 'testStoch' )
  
  console.log('passed transition');
};


var runAllTests = function(){
  smallGridTest();
  testInGrid();
  testTransition();
};


//runAllTests();

0;
