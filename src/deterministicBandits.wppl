// Multi-arm deterministic bandits.
// Rewards of arms are fixed by the latent state.
// latent state is of form {start: 0, rewards: [3,8,17]}
var makeDeterministicBandit = function (numArms) {
  var actions = _.range(numArms);
  
  var mdpTransition = function (state, action) {
    var dead = state.timeLeft - 1 == 0 ? true : false;
    return update(state, { loc:action, timeLeft:state.timeLeft - 1, dead:dead });
  };
  
  var manifestStateToActions = function (manifestState) {return actions;};

  var transition = function(state, action){
    return buildState( mdpTransition(state.manifestState, action),
		       state.latentState);
  };

  var observe = function(state){
    // agent observes the reward of arm when he chooses it
    return state.manifestState.loc === 'start' ? 0 :
      state.latentState.rewards[state.manifestState.loc];
  };
  
  return {manifestStateToActions: manifestStateToActions, transition:transition,
	  observe:observe};
};

// *armToRewards* is the actual rewards for each arm (true latentState)
// *priorBelief* is agent's belief about rewards,
// which must have true latentState in support
var runBeliefAgentBandit = function(numArms, armToRewards, priorBelief,
				    perceivedTotalTime) {
  map( function(n){assert.ok(_.isFinite(armToRewards.rewards[n]),'check armTo');},
       _.range(numArms) );
  var world = makeDeterministicBandit(numArms);
  
  // agent params 
  assert.ok( _.isFinite(priorBelief.score([],armToRewards)),
	     "actual latent not in prior's support" );

  var params = { 
    utility: function (state,action) {
      return state.manifestState.loc === 'start' ? state.latentState.start
	: state.latentState.rewards[state.manifestState.loc];
    }, // utility == reward
    alpha: 100,
    priorBelief: priorBelief
  };

  var agent = makeBeliefAgent(params, world);

  var actualTotalTime = perceivedTotalTime;
  var startState = {manifestState: {loc: 'start',
				    timeLeft: perceivedTotalTime,
				    dead: false},
		    latentState: armToRewards};

  return simulateBeliefAgent(startState, world, agent, actualTotalTime, 'states');
};
