
var recurseOnStateOrBelief = 'belief';
var fastUpdateBelief = true;
console.log(' Recurse on belief or state?  ', recurseOnStateOrBelief);
console.log(' Fast update belief? ', fastUpdateBelief);


// POMDP AGENT WITHOUT DELAYS

// Test script by running:
//webppl tests/testBeliefBandits.wppl --require webppl-timeit --require webppl-dp --require .



// Helper functions
var getFullObserve = function(observeLatent){
  return function(state){
    return {manifestState: state.manifestState, observation: observeLatent(state)};
  };
};

// Generally, we might take the union of actions for all possible states
var getBeliefToActions = function(manifestStateToActions){
  return function(belief){
    var manifestState = ERPOverLatent(belief) ? belief.manifestState : 
        sample(belief).manifestState;
    return manifestStateToActions( manifestState );
  };
};

// Agent gets an obervation in starting state without having taken an action
var isNullAction = function(action){return action=='noAction';};


// Helpers for fastUpdateBelief
var isDeltaERP = function(erp){return erp.support().length===1;};

var ERPOverLatent = function(belief){
  return _.has(belief,'manifestState') && !_.has(belief,'support');
};

var ToERPOverLatent = function(belief){
  var manifestState = belief.support()[0].manifestState;
  var latentStateERP = Enumerate(function(){return sample(belief).latentState;});
  return {manifestState: manifestState,
          latentStateERP: latentStateERP};
};


var sampleBelief = function(belief){
  if (ERPOverLatent(belief)){
    return buildState(belief.manifestState, sample(belief.latentStateERP) );
  } else {
    return sample(belief);
  };
};




var makeBeliefAgent = function(params, world) {
  map(function(s){assert.ok(params.hasOwnProperty(s),'makeBeliefAgent args');}, 
      ['utility','alpha', 'priorBelief']);
  assert.ok( isPOMDPWorld(world),
	     'world argument lacks transition, stateToActions, or observe');
  
  var utility = params.utility;
  var manifestStateToActions = world.manifestStateToActions;
  var transition = world.transition;
  var worldObserve = world.observe;
  var observe = getFullObserve(worldObserve);
  var beliefToActions = getBeliefToActions( manifestStateToActions );
  
  
  var updateBeliefLatent = dp.cache(
    function(belief, observation, action){

      // If belief has form of "ERP over {manifest:, latent:}" then we convert
      // to form of "{manifest:, ERP over latent}". 
      var belief = ERPOverLatent(belief) ? belief : ToERPOverLatent(belief);

      // To get the manifestState transition, we need a latent state and would
      // like to choose the latent state in a determinstic way
      
      // NB: Assumes that if the transition of manifestStates depends on
      // the latentState, then we always know the relevant equivalence class of
      // latent states. 
      var firstLatentState = belief.latentStateERP.support()[0];
      var state = buildState(belief.manifestState, firstLatentState);

      // For the initial 'noAction' action, don't update manifest, otherwise update it. 
      var newManifestState = isNullAction(action) ? belief.manifestState :
          transition(state,action).manifestState;
      
      // Don't update latent when you don't need to
      if (observation=='noObservation' || isDeltaERP(belief.latentStateERP) ){
        return update(belief, {manifestState: newManifestState});
      } else {

        // Sample latent, update state, compare predicted observation from state
        // to actual observation. 
        var newLatentERP = Enumerate(function(){
          var latentState = sample(belief.latentStateERP);
	  var state = buildState( belief.manifestState, latentState);    
          var predictedNextState = isNullAction(action) ? state : transition(state, action);
          var predictedObservation = observe(predictedNextState);
	  condition(_.isEqual(predictedObservation, observation));
	  return latentState;});
        var out =  {manifestState: newManifestState, latentStateERP: newLatentERP};
        
        return out;
      }
    });
      
  var updateBeliefSimple = dp.cache(
    function(belief, observation, action){
      return Enumerate(function(){
	var state = sample(belief);
        var predictedNextState = isNullAction(action) ? state : transition(state, action);
        var predictedObservation = observe(predictedNextState);
	condition(_.isEqual(predictedObservation, observation));
	return predictedNextState;
	});
    });

  var updateBelief = fastUpdateBelief ? updateBeliefLatent : updateBeliefSimple;

  
  // RECURSE ON BELIEF (BELLMAN STYLE)
  var act = dp.cache(
    function(belief) {
      //assert.ok(isERP(belief.latentStateERP), 'agent args fail');
    
      return Enumerate(function(){
	var action = uniformDraw(beliefToActions(belief));
	var eu = expectedUtilityBelief(belief, action);
	factor(params.alpha * eu);
	return action;
      });
    });
  
  var expectedUtilityBelief = dp.cache(
    function(belief, action) {
      return expectation(
	Enumerate(function(){
	  var state = sampleBelief(belief);
	  var u = utility(state, action);
	  if (state.manifestState.dead) {
	    return u;
	  } else {
	    var nextState = transition(state, action);
	    var nextObservation = observe(nextState);
	    var nextBelief = updateBelief(belief, nextObservation, action);            
	    var nextAction = sample(act(nextBelief));
            
	    var futureU = expectedUtilityBelief(nextBelief, nextAction);
	    return u + futureU;
	  }
	}));
    });

  // RECURSE ON STATE (FIXES THE LATENT STATE)
  var act_recState = dp.cache(
    function(belief) {
//      assert.ok(isERP(belief), 'act args fail');
      
      return Enumerate(function(){
	var action = uniformDraw(beliefToActions(belief));
	var eu = expectedUtilityBelief_recState(belief, action);
	factor(params.alpha * eu);
	return action;
      });
    });

  var expectedUtilityBelief_recState = dp.cache(
    function(belief, action){
      return expectation(
        Enumerate( function(){
          var state = sampleBelief(belief);
          return expectedUtilityState_recState(belief,state, action);
        }));
    });
  
  var expectedUtilityState_recState = dp.cache(
    function(belief, state, action){
      return expectation(  // need this for caching
        Enumerate( function(){
          var u = utility(state, action);
          if (state.manifestState.dead) {
	    return u;
          } else {
	    var nextState = transition(state, action);
	    var nextObservation = observe(nextState);
	    var nextBelief = updateBelief(belief, nextObservation, action);            
	    var nextAction = sample(act(nextBelief));
            var futureU = expectedUtilityState_recState(nextBelief, nextState, nextAction);
	    return u + futureU; 
          }
        }));
    });

  var act = recurseOnStateOrBelief === 'belief' ? act : act_recState;
  var expectedUtilityBelief = recurseOnStateOrBelief === 'belief' ? 
      expectedUtilityBelief : expectedUtilityBelief_recState;

  return {
    act: act,
    expectedUtilityBelief: expectedUtilityBelief,
    params: params,
    updateBelief: updateBelief};
};



var simulateBeliefAgent = function (startState, world, agent, actualTotalTime,
				    outputType) {

  var perceivedTotalTime = startState.manifestState.timeLeft;
  assert.ok( isPOMDPWorld(world),
	     'world argument lacks transition, stateToActions, or observe');
  assert.ok( actualTotalTime <= perceivedTotalTime && isPOMDPState(startState),
	     'simulate args: ' + [actualTotalTime, perceivedTotalTime]);
  assert.ok( perceivedTotalTime  > 1, 'perceivedTime<=1. If=1 then should have state.dead, but then simulate wont work');

  var agentAct = agent.act;
  var priorBelief = agent.params.priorBelief;
  var agentUpdateBelief = agent.updateBelief;
  var transition = world.transition;
  var worldObserve = world.observe;
  var observe = getFullObserve(worldObserve);

  var selectOutput = function(state, nextAction, currentBelief){
    var table =  {
      states:state,
      actions:nextAction,
      stateAction:[state, nextAction], 
      stateBelief: [state, currentBelief]
    };
    assert.ok( _.has(table,outputType), "outputType key not in ['states', 'actions', 'stateAction', 'stateBelief']");
    return table[outputType];
  };
  
  var shouldTerminate = (isGridworld(world) ?
                       function (actualTimeLeft, state) { return actualTimeLeft === 0 || state.dead; } :
                         function (actualTimeLeft, state) { return actualTimeLeft === 0; });

  var sampleSequence = function(state, belief, action, actualTimeLeft) {
    if (shouldTerminate(actualTimeLeft, state.manifestState) ) {
      return [];
    } else {
      var nextObservation = observe(state);

      // update agent's internal state and get action
      var nextBelief = agentUpdateBelief(belief, nextObservation, action);
      var nextAction = sample(agentAct(nextBelief));

      // update world state, return immediate output and output from recursing
      // on updated world state, agent belief, and time.
      var nextState = transition(state, nextAction);
      var output = selectOutput(state, nextAction, belief);
      
      return [output].concat( sampleSequence(nextState, nextBelief, nextAction,
					     actualTimeLeft - 1));
    }
  };
  var startAction = 'noAction';
  return sampleSequence(startState, priorBelief, startAction, actualTotalTime);
};


