
// note: isGridworld is different in this file than how it is in other files
var isGridworld = function(world){return world
				  && arraysEqual(world.actions,
						     ['l', 'r', 'u', 'd'])
				  && world.hasOwnProperty('feature')
				  && world.hasOwnProperty('xLim')
				  && world.hasOwnProperty('yLim')
				  && world.hasOwnProperty('transition');};


// function that builds a gridworld POMDP

// arg is a gridworld MDP, which is an object with features (an array of
// arrays of the features at each point), xLim, yLim, feature (a function of
// a (manifest) state that returns the features of that state), transition
// (a transition function on manifest states), actions, and stateToActions.
// noReverse must be false in the MDP.

// manifest states in this POMDP are objects with loc (an array of two
// numbers), timeLeft, terminateAfterAction, and timeAtRestraurant - the same as states in gridworld MDPs.
// latent states are an object listing whether each restaurant type is open.
// transition acts the same as in gridworld MDPs, not touching the latent state,
// unless the transition would take the agent into a closed restaurant, in which
// case the agent stays put.
// observe tells the agent which adjacent restaurants are open. If the agent is not
// adjacent to any restaurants, they get 'noObservation'.
var makeGridworldPOMDP = function(gridworld) {
  assert.ok(isGridworld(gridworld), 'makeGridworldPOMDP arg');

  var actions = gridworld.actions;
  var feature = gridworld.feature;

  // returns an array of restaurants that neighbour a state
  var neighbourRestaurants = function(manifestState) {
    var loc = manifestState.loc;
    var updateStateLoc = function(manifestState, newLoc) {
      return update(manifestState, {loc: newLoc});
    };
    
    var potentialneighbourStates = [
      updateStateLoc(manifestState, [loc[0] - 1, loc[1]]),
      updateStateLoc(manifestState, [loc[0] + 1, loc[1]]),
      updateStateLoc(manifestState, [loc[0], loc[1] + 1]),
      updateStateLoc(manifestState, [loc[0], loc[1] - 1]),
    ];

    var neighbourStates = filter(function(manifestState){
      return inGrid_(gridworld, manifestState.loc);
    }, potentialneighbourStates);

    var isRestaurant = function(manifestState) {
      return feature(manifestState).name;
    };

    return filter(isRestaurant, neighbourStates);
  };

  // returns a subobject of latentState that gives the status of adjacent restaurants
  var observe = function(state) {
    var neighbourRests = neighbourRestaurants(state.manifestState);
    if (_.isEmpty(neighbourRests)) {
      return 'noObservation';
    } else {
      var restaurantNames = map(function(manifestState){
	return feature(manifestState).name;}, neighbourRests);
      
      return map(function(name){return [name, state.latentState[name]];},
		 restaurantNames);
    }
  };

  
  var _mdpTransition = gridworld.transition;
  var mdpTransition = function(state, action) {
    // transition the manifest state as it would be transitioned in the gridworld
    // mdp, leave the latent state alone
    var newManifestState = _mdpTransition(state.manifestState, action);
    return buildState(newManifestState, state.latentState);
  };

  var transition = function(state, action) {
    assert.ok(isPOMDPState(state), 'transition state arg');

    var proposedNewState = mdpTransition(state, action);
    var newFeatureName = feature(proposedNewState.manifestState).name;

    // if proposedNewState is a restaurant that is closed, stay put, but increment
    // time. otherwise, change to proposed new state.
    if (newFeatureName && !proposedNewState.latentState[newFeatureName]) {
      return buildState(advanceStateTime(state.manifestState), state.latentState);
    } else {
      return proposedNewState;
    }
  };


  var manifestStateToActions = function(manifestState){
    var neighbourRestaurantArray = neighbourRestaurants(manifestState);
    if (neighbourRestaurantArray.length == 0) {
      var manifestStateToActions_ = gridworld.stateToActions;
      return manifestStateToActions_(manifestState);
    } else {
      return gridworld.actions;
    }
  };
  
  return {manifestStateToActions: manifestStateToActions,
	  transition: transition,
	  observe: observe};
};




// Make big gridworld
var getBigDonutWorld = function(){
  var gridworldMDP = makeDonutWorld2({big: true});
  var feature = gridworldMDP.feature;
  return update(makeGridworldPOMDP(gridworldMDP), {feature:feature});
};


var tableToUtilityFunction = function(table, feature) {  
  return function(state, action) {
    var stateFeatureName = feature(state.manifestState).name;
    if (stateFeatureName) {  
      return table[stateFeatureName];
    } else {
      return table.timeCost;
    }
  };
};


var baseParamsNoDiscount = {
  priorBelief: null,
  utility: null,
  alpha: 100,
  noDelays: true,
  discount: 0,
  sophisticatedOrNaive: 'sophisticated',
  myopia: {on: false, bound: 0},
  boundVOI: {on: false, bound: 0},
};




var inferGridWorldPOMDP = function(world, startState, baseParams, trueAgentParams, prior, agentTypeAndFunctions,
                                   trajectoryOrOffPolicy, numRejectionSamples){
  
  var worldObserve = world.observe;
  var observe = getFullObserve(worldObserve);
  var feature = world.feature;
  
  var makeAgent = agentTypeAndFunctions.makeAgent;
  var simulate = agentTypeAndFunctions.simulate;
  var beliefOrBeliefDelay = agentTypeAndFunctions.type;

  var priorUtilityTable = prior.priorUtilityTable
  var priorAgentPrior = prior.priorAgentPrior;

  assert.ok(isPOMDPState(startState) && isERP(priorUtilityTable) && isERP(priorAgentPrior), 'inferGridworld args');
  assert.ok(trajectoryOrOffPolicy == 'trajectory' || trajectoryOrOffPolicy=='offPolicy', 
            'trajectoryOrOffPolicy is not valid');
  
  assert.ok(_.isNumber(numRejectionSamples) && isPOMDPWorld(world), 'inferGridWorld args' );

  
  // get observations using trueAgentParams
  var agent = makeAgent(trueAgentParams, world);
  var observedStateAction = simulate(startState, world, agent, 'stateAction');
  // console.log('observed trajectory: ', JSON.stringify(observedStateAction));
  // ash();
  assert.ok( isPOMDPState(observedStateAction[0][0]), 'fullstate in trajectory for inferGridWorld');
  
  
  return Enumerate(function(){
    var utilityTable = sample(priorUtilityTable);
    var utility = tableToUtilityFunction(utilityTable, feature);

    var priorBelief = sample(priorAgentPrior);
    
    var params = update(baseParams, {utility:utility, priorBelief: priorBelief});
    
    var agent = makeAgent(params, world);
    var agentAct = agent.act;
    var agentUpdateBelief = agent.updateBelief;

    // Factor on whole sampled trajectory (SLOW IF TRANSITIONS NOT DETERMINISTIC OR IF NUM SAMPLES HIGH)
    var factorOnTrajectory = function(){
      var trajectoryERP = Rejection( function(){
        return simulate(startState, world, agent, 'states')}, numRejectionSamples);
      factor(trajectoryERP.score([], map(first, observedStateAction)));
    };

    
    // Move agent through observed sequence 
    var factorSequenceOffPolicy = function(currentBelief, previousAction, timeIndex){
      if (timeIndex < observedStateAction.length) { 

        // Go to next world state and sample observation from that state
        var state = observedStateAction[timeIndex][0];
        var observation = observe(state);

        // Update agent's internal state and get action ERP
        var delay = 0;     
        var nextBelief = beliefOrBeliefDelay == 'belief' ?
            agentUpdateBelief(currentBelief, observation, previousAction) :
            agentUpdateBelief(currentBelief, observation, previousAction, delay);


        var nextActionERP = beliefOrBeliefDelay == 'belief' ? 
            agentAct(nextBelief) : agentAct(nextBelief, delay); 

        var observedAction = observedStateAction[timeIndex][1];
        factor(nextActionERP.score([], observedAction));

        // condition on next world state, passing through updated internal state
        factorSequenceOffPolicy(nextBelief, observedAction, timeIndex + 1);
      }
    };

    var doInfer = (trajectoryOrOffPolicy=='trajectory') ? factorOnTrajectory() : 
        factorSequenceOffPolicy(priorBelief,'noAction', 0);
    
    return {utilityTable: utilityTable,
	    priorBelief: priorBelief};
  });
};
