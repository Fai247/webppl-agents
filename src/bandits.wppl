// Stochastic bandit pomdp constructor. Can output bandits whose prizes are
// strings or numbers.

// The latent state stores each arm's ERP over prizes, and the manifest state
// location contains the reward gained after the previous arm pull.

var makeBanditWorld = function(numberArms) {
  var actions = range(numberArms);

  var advanceTime = function(manifestState) {
    var newTimeLeft = manifestState.timeLeft - 1;
    var terminateAfterAction = (newTimeLeft === 1);
    return update(manifestState, {timeLeft: newTimeLeft,
  				  terminateAfterAction: terminateAfterAction});
  };
  
  var manifestStateToActions = function(manifestState) {return actions;};

  var transition = function(state, action){
    // figure out what the prize is
    var prize = sample(state.latentState[action]);

    // make the new location the prize, advance the time
    var manifestStateWithReward = update(state.manifestState, {loc: prize});
    var newManifestState = advanceTime(manifestStateWithReward);
    
    return buildState( newManifestState, state.latentState);
  };

  var observe = function(state){
    // in beliefAgent, the observation here will be augmented with an 
    // observation of the manifest state, and belief updating will depend on
    // both that full observation and the action the agent took. This is all the
    // agent needs to update, so there is no need to have an observation here.
    // However, if we make the observation 'noObservation', the agent will not
    // update its beliefs, which is bad, so we arbitrarily set the observation
    // to always be 0.

    return 0;

  };

  return {manifestStateToActions: manifestStateToActions,
	  transition: transition,
	  observe: observe};
};

var makeBanditStartState = function(numberTrials, armToPrizes) {
  return {manifestState: {loc: 'start',
			  timeLeft: numberTrials,
			  terminateAfterAction: false},
	  latentState: armToPrizes};
};

var numericBanditUtility = function(state, action) {
  var prize = state.manifestState.loc;
  return prize === 'start' ? 0 : prize;
};

var makeStringBanditUtility = function(prizeToUtility) {
  return function(state, action) {
    var prize = state.manifestState.loc;
    return prize === 'start' ? 0 : prizeToUtility[prize];
  };
};

var makeBandit = function(numberArms, armToPrizes, numberTrials,
			  numericalPrizes, prizeToUtility) {

  // ensure that armToPrizes has an entry for every arm
  mapN(function(n){
    assert.ok(_.has(armToPrizes, _.toString(n)),
	      'not every arm has an entry in armToPrizes in makeBandit');
  }, numberArms);
  
  // ensure that armToPrizes has an ERP for every arm
  mapN(function(arm){
    assert.ok(isERP(armToPrizes[arm]),
	      'not every arm has an ERP in armToPrizes in makeBandit');
  }, numberArms);

  // ensure that prizes are numerical iff numericalPrizes is true,
  // and strings iff numericalPrizes is false
  // also, if numericalPrizes is false, and prizeToUtility is defined, ensure
  // that every prize has a utility
  if (numericalPrizes) {
    var supportIsNumeric = function(arm) {
      var erp = armToPrizes[arm];
      map(function(x){
	assert.ok(_.isFinite(x) && inSupport(x, erp),
		  'makeBandit: some prizes are non-numeric but numericalPrizes is true');
      }, erp.support);
    };

    mapN(supportIsNumeric, numberArms);
    
  } else {
    var supportIsStringy = function(arm) {
      var erp = armToPrizes[arm];
      map(function(x){
	assert.ok(_.isString(x) && inSupport(x, erp),
		  'makeBandit: some prizes are not strings but numericalPrizes is false');
      }, erp.support);
    };

    mapN(supportIsStringy, numberArms);

    if (prizeToUtility) {
      var prizesHaveUtilities = function(arm) {
	var erp = armToPrizes[arm];
	map(function(x){
	  assert.ok(_.isFinite(prizeToUtility[x]) && inSupport(x, erp),
		    'makeBandit: some prizes do not have utilities');
	}, erp.support);
      };

      mapN(prizesHaveUtilities, numberArms);
      
    } 
  }
  
  var world = makeBanditWorld(numberArms);
  var startState = makeBanditStartState(numberTrials, armToPrizes);
  var utility = numericalPrizes ? numericBanditUtility :
	makeStringBanditUtility(prizeToUtility);

  return {world: world, startState: startState, utility: utility};
};

// agentParams does not require utility argument
var makeBanditAgent = function(agentParams, worldAndStart, beliefOrBeliefDelay,
			       numericalPrizes, prizeToUtility) {
  var priorBelief = agentParams.priorBelief;

  if (ERPOverLatent(priorBelief)) {
    assert.ok(_.isEqual(priorBelief.manifestState,
			worldAndStart.startState.manifestState),
	      'makeBanditAgent: priorBelief has wrong start manifestState');
  } else {
    assert.ok(_.isEqual(sample(priorBelief).manifestState,
			worldAndStart.startState.manifestState),
	      'makeBanditAgent: priorBelief has wrong start manifestState');
  }
  
  var utility = numericalPrizes ? numericBanditUtility :
	makeStringBanditUtility(prizeToUtility);

  var makeAgent = getMakeAgentFunction(beliefOrBeliefDelay);

  return makeAgent(update(agentParams, {utility:utility}), worldAndStart.world);
};

// alternative makeBanditAgent that takes an object with world, startState,
// and utility
var _makeBanditAgent = function(agentParams, worldStartAndUtility,
				beliefOrBeliefDelay){
  var priorBelief = agentParams.priorBelief;

  if (ERPOverLatent(priorBelief)) {
    assert.ok(_.isEqual(priorBelief.manifestState,
			worldAndStart.startState.manifestState),
	      '_makeBanditAgent: priorBelief has wrong start manifestState');
  } else {
    assert.ok(_.isEqual(sample(priorBelief).manifestState,
			worldAndStart.startState.manifestState),
	      '_makeBanditAgent: priorBelief has wrong start manifestState');
  }

  var makeAgent = getMakeAgentFunction(beliefOrBeliefDelay);

  return makeAgent(update(agentParams, {utility: worldStartAndUtility.utility}),
		   worldStartAndUtility.world);
};
