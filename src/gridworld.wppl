// import gridworld-viz library
var GridWorld = webpplGridworld;

var inGrid_ = function(gridMap, loc) {
  return (loc[0] >= 0 && loc[0] < gridMap.xLim &&
          loc[1] >= 0 && loc[1] < gridMap.yLim);
}

var isBlockedLoc = function(gridMap, loc) {
  var getFeature = gridMap.feature;
  var feature = getFeature({ loc : loc});
  return feature === '#';
}

var isAllowedState_ = function(gridMap, loc) {
  return (inGrid_(gridMap, loc)) && !isBlockedLoc(gridMap, loc);
};

var advanceStateTime = function(state) { 
  return update(state, { 
    timeLeft : state.timeLeft - 1, 
    terminateAfterAction : state.timeLeft - 1> 1 ? state.terminateAfterAction : true, 
    previousLoc : state.loc
  });
};

var addPrevious = function(state) { 
  return update(state, { previousLoc : state.loc });
};

var advanceRestaurant = function(state, maxTimeAtRestaurant) { 
  var timeAtRestaurant = (state.timeAtRestaurant === undefined) ? 0 : state.timeAtRestaurant + 1 ;
  var state = update(state, { timeAtRestaurant : timeAtRestaurant }); 

  if (state.timeAtRestaurant < maxTimeAtRestaurant - 1) {
    return state;
  } else {
    return update(state, { terminateAfterAction : true });
  }
};

var moveState = function(gridMap, state, action) { 
  var loc = state.loc;
  var gridTransition = {l: [loc[0]-1, loc[1]],
                        r: [loc[0]+1, loc[1]],
                        u: [loc[0], loc[1]+1],
                        d: [loc[0], loc[1]-1]};

  var possibleNextLoc = gridTransition[action];
  assert.ok(possibleNextLoc != undefined, 'action was not found');

  var nextLoc = isAllowedState_(gridMap, possibleNextLoc) ? possibleNextLoc : loc;
  return update(state, { loc : nextLoc });
};

var makeGridTransition_ = function(gridMap, options) {
  return function(state,action){
    var getFeature = gridMap.feature;
    var state = options.noReverse ? addPrevious(state) : state;
    var state = !getFeature(state).name ? advanceStateTime(state) : state;

    var state = !getFeature(state).name ? moveState(gridMap, state, action) : state;
    var state = getFeature(state).name ? advanceRestaurant(state, options.maxTimeAtRestaurant) : state;

    return state;
  };
};

var makeNoisyGridTransition_ = function(gridMap, options, transitionNoiseProb) {
  var deterministicTransition = makeGridTransition_(gridMap, options);
  // If agent selects *key*, with *transitionNoiseProb* they do one of the two
  // orthogonal actions
  var noiseActionTable = {u: ['l','r'],
			  d: ['l','r'],
			  l: ['u','d'],
			  r: ['u','d']};

  return function(state,action){
    return flip(1-transitionNoiseProb) ? deterministicTransition(state,action)
      : deterministicTransition(state, uniformDraw(noiseActionTable[action]));
  };
};


var makeGridMap = function(rfeatures)  { 
  var features = rfeatures.reverse();
  return { 
    features : features,
    xLim : features[0].length,
    yLim : features.length,
    feature : function (state) { 
      return features[state.loc[1]][state.loc[0]];
    }
  };
};





var makeHike = function(transitionNoiseProb, options) {
  assert.ok( _.isFinite(transitionNoiseProb) && 0 <= transitionNoiseProb
	    && transitionNoiseProb <= 1,
	    'something wrong with transitionNoiseProb argument to makeHike');

  var H = {name: 'Hill'};
  var W = {name: 'West'};
  var E = {name: 'East'};
  var __ = ' ';
  
  var smallFeatures =
	[[ __ ,  __ ,  __ ,  __ ,  __ ],
	 [ __ , '#',  __ ,  __ ,  __ ],
	 [ __ , '#',  W , '#',  E ],
	 [ __ ,  __ ,  __ ,  __ ,  __ ],
	 [ H ,  H ,  H ,  H ,  H ]];

  var bigFeatures =
	[[ __ ,  __ ,  __ ,  __ ,  __ ,  __ ],
	 [ __ ,  __ ,  __ ,  __ ,  __ ,  __ ],
	 [ __ ,  __ , '#',  __ ,  __ ,  __ ],
	 [ __ ,  __ , '#',  W , '#',  E ],
	 [ __ ,  __ ,  __ ,  __ ,  __ ,  __ ],
	 [ H ,  H ,  H ,  H ,  H ,  H ]];

  var options_ = options ? options : {big: false};
  
  var features = options_.big ? bigFeatures : smallFeatures;
  
  return makeNoisyGridworld(features, options_, transitionNoiseProb);
};


var makeGridWorld = function(features, options) {
  var defaults = { noReverse : false, maxTimeAtRestaurant : 1 };

  var options = update(defaults, options);
  var gridMap = makeGridMap(features); 

  var transition = makeGridTransition_(gridMap, options);
  var actions = ['l', 'r', 'u', 'd'];

  var stateToActions = function (state) { 

    var possibleActions = filter(function (action) { 
      var newState = transition(state, action);
      if (options.noReverse && 
          state.previousLoc && 
          state.previousLoc[0] === newState.loc[0] && state.previousLoc[1] === newState.loc[1]) { return false; }
      return state.loc[0] !== newState.loc[0] || state.loc[1] !== newState.loc[1];
    }, actions);

    if (possibleActions.length > 0) {
      return possibleActions;
    } else { 
      return [actions[0]];
    }
  };

  return update(gridMap,
    { transition : transition, 
      actions    : actions,
      stateToActions    : stateToActions
    });
};


var makeNoisyGridworld = function(features, inputOptions, transitionNoiseProb) {
  var defaults = { noReverse: false, maxTimeAtRestaurant : 1 };

  var options = update(defaults, inputOptions);
  var gridMap = makeGridMap(features); 

  var transition = makeNoisyGridTransition_(gridMap, options,
					    transitionNoiseProb);
  var actions = ['l', 'r', 'u', 'd'];

  var stateToActions = function (state) { 
    var possibleActions = filter(function (action) {
      // if noReverse, check that MAP of newState doesn't reverse you
      var transitionERP = Enumerate(function(){
	return transition(state, action);
      });
      var likelyNewState = MAP(transitionERP).val;
      if (options.noReverse && state.previousLoc
	  && state.previousLoc[0] === likelyNewState.loc[0]
	  && state.previousLoc[1] === likelyNewState.loc[1]) {
	return false;
      } else {
	return state.loc[0] !== likelyNewState.loc[0]
	  || state.loc[1] !== likelyNewState.loc[1];
      }}, actions);
			

    if (possibleActions.length > 0) {
      return possibleActions;
    } else { 
      return [actions[0]];
    }
  };

  return update(gridMap,
    { transition : transition, 
      actions : actions,
      stateToActions : stateToActions
    });
};





// Restaurant Choice Constructor and Helpers

var restaurant = {
  donutN : { name : 'Donut N'},
  donutS : { name : 'Donut S'},
  veg   : { name : 'Veg'},
  noodle: { name : 'Noodle'}
};

var makeDonutWorld2 = function(options) { 
  var __ = ' '; 
  var DN = restaurant.donutN;
  var DS = restaurant.donutS;
  var V = restaurant.veg;
  var N = restaurant.noodle;

  var options = options || {};

  var small = 
    [['#', '#', '#',  V , '#'],
     ['#', '#',  __ ,  __ ,  __ ],  
     ['#', DN ,  __ , '#',  __ ],
     ['#', '#',  __ ,  __ ,  __ ],
     ['#', '#',  __ , '#',  N ],
     [ __ ,  __ ,  __ , '#', '#'],
     [DS , '#',  __ , '#', '#']];

  var big = 
    [['#', '#', '#', '#',  V , '#'],
     ['#', '#', '#',  __ ,  __ ,  __ ],  
     ['#', '#', DN ,  __ , '#',  __ ],
     ['#', '#', '#',  __ , '#',  __ ],
     ['#', '#', '#',  __ ,  __ ,  __ ],
     ['#', '#', '#',  __ , '#',  N ],
     [ __ ,  __ ,  __ ,  __ , '#', '#'],
     [DS , '#', '#',  __ , '#', '#']];

  var features = options.big ? big : small;
  return makeGridWorld(features, options);
};

var makeRestaurantChoiceMDP = function(options){
  if (options){
    return makeDonutWorld2( update(options,{big:true} ) );
  } else {
    return makeDonutWorld2( update(options,{big:true, noReverse:true, maxTimeAtRestaurant:2} ) );
  }
};


var restaurantChoiceMDP = makeDonutWorld2({ big : true, noReverse : true, maxTimeAtRestaurant : 2});
var restaurantChoiceStart = { 
  loc : [3,1],
  terminateAfterAction : false,
  timeLeft : 11
};




// trajectories starting from [3,1] for big donutWorld
var restaurantNameToPath = {
  naive: [[3,1], [3,2], [3,3], [3,4], [3,5], [2,5], [2,5]],
  
  sophisticated: [[ 3, 1 ],[ 3, 2 ],[ 3, 3 ],[ 4, 3 ], [ 5, 3 ],
                  [ 5, 4 ], [ 5, 5 ], [ 5, 6 ], [4, 6 ], [ 4, 7 ], [4,7] ],

  donutNorth: [[3,1], [3,2], [3,3], [3,4], [3,5], [2,5], [2,5]],
  
  donutSouth: [[3,1], [2,1], [1,1], [0,1], [0,0], [0,0]],
  
  vegDirect: [[3,1], [3,2], [3,3], [3,4], [3,5], [3,6], [4,6], [4,7], [4,7]]
};

var restaurantNameToPathSmall = {
  naive: [[2,1], [2,2], [2,3], [2,4], [1,4]],
  sophisticated: [[2,1], [2,2], [2,3], [3,3], [4,3], [4,4], [4,5], [3,5], [3,6]]
};

var restaurantNameToObservationTime11 = {
  naive: 
  [[{"loc":[3,1],"terminateAfterAction":false,"timeLeft":11},"u"],
   [{"loc":[3,2],"terminateAfterAction":false,"timeLeft":10,"previousLoc":[3,1]},"u"],
   [{"loc":[3,3],"terminateAfterAction":false,"timeLeft":9,"previousLoc":[3,2]},"u"],
   [{"loc":[3,4],"terminateAfterAction":false,"timeLeft":8,"previousLoc":[3,3]},"u"],
   [{"loc":[3,5],"terminateAfterAction":false,"timeLeft":7,"previousLoc":[3,4]},"l"],
   [{"loc":[2,5],"terminateAfterAction":false,"timeLeft":6,"previousLoc":[3,5],"timeAtRestaurant":0},"l"],
   [{"loc":[2,5],"terminateAfterAction":true,"timeLeft":6,"previousLoc":[2,5],"timeAtRestaurant":1},"l"]],

  sophisticated:
  [[{"loc":[3,1],"terminateAfterAction":false,"timeLeft":11},"u"],[{"loc":[3,2],"terminateAfterAction":false,"timeLeft":10,"previousLoc":[3,1]},"u"],[{"loc":[3,3],"terminateAfterAction":false,"timeLeft":9,"previousLoc":[3,2]},"r"],[{"loc":[4,3],"terminateAfterAction":false,"timeLeft":8,"previousLoc":[3,3]},"r"],[{"loc":[5,3],"terminateAfterAction":false,"timeLeft":7,"previousLoc":[4,3]},"u"],[{"loc":[5,4],"terminateAfterAction":false,"timeLeft":6,"previousLoc":[5,3]},"u"],[{"loc":[5,5],"terminateAfterAction":false,"timeLeft":5,"previousLoc":[5,4]},"u"],[{"loc":[5,6],"terminateAfterAction":false,"timeLeft":4,"previousLoc":[5,5]},"l"],[{"loc":[4,6],"terminateAfterAction":false,"timeLeft":3,"previousLoc":[5,6]},"u"],[{"loc":[4,7],"terminateAfterAction":false,"timeLeft":2,"previousLoc":[4,6],"timeAtRestaurant":0},"l"],[{"loc":[4,7],"terminateAfterAction":true,"timeLeft":2,"previousLoc":[4,7],"timeAtRestaurant":1},"l"]],

  vegDirect: 
  [[{"loc":[3,1],"terminateAfterAction":false,"timeLeft":11},"u"],[{"loc":[3,2],"terminateAfterAction":false,"timeLeft":10,"previousLoc":[3,1]},"u"],[{"loc":[3,3],"terminateAfterAction":false,"timeLeft":9,"previousLoc":[3,2]},"u"],[{"loc":[3,4],"terminateAfterAction":false,"timeLeft":8,"previousLoc":[3,3]},"u"],[{"loc":[3,5],"terminateAfterAction":false,"timeLeft":7,"previousLoc":[3,4]},"u"],[{"loc":[3,6],"terminateAfterAction":false,"timeLeft":6,"previousLoc":[3,5]},"r"],[{"loc":[4,6],"terminateAfterAction":false,"timeLeft":5,"previousLoc":[3,6]},"u"],[{"loc":[4,7],"terminateAfterAction":false,"timeLeft":4,"previousLoc":[4,6],"timeAtRestaurant":0},"l"],[{"loc":[4,7],"terminateAfterAction":true,"timeLeft":4,"previousLoc":[4,7],"timeAtRestaurant":1},"l"]]
};

var restaurantNameToObservationTime11Reverse = function(name){
  var ar = restaurantNameToObservationTime11[name];
  return map( function(stateAction){
    var state = stateAction[0];
    var state_noPrevious = _.omit(state,'previousLoc');
    return [state_noPrevious, stateAction[1]];
  }, ar);
};

var allButLast = function(ar){return ar.slice(0,ar.length-1);};

var restaurantPathToName = function(path){
  var table = _.invert(restaurantNameToPath);
  var name = table[path] || 'not in table';
  return 'path: ' + name;
};


var makeRestaurantUtilityMDP = function (world, utilityTable) { 
  return function(state, action) {
    var getFeature = world.feature;
    var feature = getFeature(state);

    if (feature.name) { return utilityTable[feature.name][state.timeAtRestaurant]; }
    return utilityTable.timeCost || -.01;
  };
};
