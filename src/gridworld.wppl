/* jshint shadow: true, newcap: false, maxerr:500, sub:false, latedef:false */

var GridWorld = webpplGridworld; // reference to the exports of gridworld.js



// GridWorld library and MDP agent


// Agent models helper functions
var argMax = function(f,ar){return maxWith(f,ar)[0]};


// Helper Functions
var ash = function(){assert.ok(0,'assert halt');};

var range = function(n){
  if (n===0){return [];} 
  else {return range(n-1).concat([n-1]);}
};

var downToOne = function(n){
  if (n==0){return [];}
  else {return [n].concat(downToOne(n-1));}
};

var selectIndex = function(ar,i){
    return  map(function(tuple){return tuple[i];}, ar);
};

var arraysEqual = function(xs, ys){
  return JSON.stringify(xs) === JSON.stringify(ys);
};

var printERP = function(x,k) {
  var erpValues = sort(x.support(), undefined, function(v){return -x.score([], v);});
  var erpValues = typeof(k)=='undefined' ? erpValues : erpValues.slice(0,k);
  map(
    function(v){
      var prob = Math.exp(x.score([], v));
      if (prob > 0.0){
        console.log(JSON.stringify(v) + ': ' + prob.toFixed(5));
      }
    },
    erpValues);
};

var update = function(base, ext){
  return _.extend({}, base, ext);
};




// GRIDWORLD LIBRARY

// States have form [x,y] with Cartesian coordinates
// Grid dimenions are called xLim and yLim
// Actions don't include "stay" or diagonal moves.
// Agent gets rewards on exiting a state. 
// Transition function can be stochastic. 

var gridActions = ['l','r','u','d'];  // left, right, up, down


// NB: treats the postTerminal as distinct from the terminal
var gridEqual = function(state1,state2){
  return arraysEqual(state1,state2);
};

// a gridworld state is in an array of states
var stateInArray = function(state,ar){
  assert.ok(state.length==2 & ar.length >= 0, 'stateInArray args');
  return any( function(x){return x===true;},
              map( function(x){return gridEqual(x,state)}, ar));
};

// After entering a terminal, agent goes to "postTerminal" for rest of time
var isPostTerminal = function(state){return state[0]=='dead';};

var inGrid = function(xLim, yLim, state){ 
  return (indexOf(state[0],range(xLim)) != undefined) & (indexOf(state[1],range(yLim)) != undefined);
};

var isBlockedState = function(state,blockedStates){
  return stateInArray(state,blockedStates);
};

var openToBlocked = function(open, xLim, yLim){
  var fullGrid = GridWorld.getGridStates(xLim, yLim);
  return filter( function(state){return !stateInArray(state,open);}, fullGrid);
};



//  Construct gridworld transition function
var makeGridTransition = function(xLim, yLim, blockedStates, terminals){
  
  assert.ok( xLim>1 | yLim>1, 'makeGridTransition');

  var isAllowedState = function(state){
    return (inGrid(xLim, yLim, state) | isPostTerminal(state)) & !isBlockedState(state,blockedStates) ;
  };

  return function(state,action){    
    assert.ok( isAllowedState(state), 'current state is not allowed');
    assert.ok( indexOf( action, gridActions ) != undefined, 'action in gridActions');
    
    var gridTransition = {l: [state[0]-1, state[1]],
                          r: [state[0]+1, state[1]],
                          u: [state[0], state[1]+1],
                          d: [state[0], state[1]-1]};

    // terminals: ignore action
    if (stateInArray(state, terminals)){return ['dead', state[0], state[1]];}
    if (isPostTerminal(state)){return state;}

    var possibleNextState = gridTransition[action];
    return isAllowedState(possibleNextState) ? possibleNextState : state
  };
};

// Build a closure for {state: actions_in_state}, where actions are those
// that transition to a different states. Won't work if we add a 'stay' action
// to gridworld actions

var getStateToActions = function(detTransition, blockedStates, xLim, yLim){
  var allStates = GridWorld.getGridStates(xLim,yLim);
  var states = filter( function(s){return !stateInArray(s,blockedStates);}, allStates);
  var actions = ['l','r','u','d'];
  
  var actionsAr = map(function(state){
    return filter(function(a){ 
      return !gridEqual(detTransition(state,a), state);
    }, actions);
  }, states);

  // [state, actions] -> {state:actions}
  var stateToActions = GridWorld.zipToObject( zip(states,actionsAr) );
                          
  return function(state){return stateToActions[state];};
};



// Standard stochastic transitions, where agent sometimes goes in orthogonal direction
// to the one intended. We implement this by using a deterministic transition function
// and stochastically changing the action the agent performs.

var makeStochasticGridTransition = function(xLim, yLim, blockedStates, transitionNoiseProb, terminals){

  var detTransition = makeGridTransition(xLim, yLim, blockedStates, terminals);

  // If agent selects *key*, with *transitionNoiseProb* they do one of the two orthogonal actions
  var noiseActionTable = {u: ['l','r'], d: ['l','r'], l: ['u','d'], r: ['u','d'] };
  
  return function(state,action){
    sample(Enumerate( function(){
      return flip(1-transitionNoiseProb) ? detTransition(state,action) : 
        detTransition(state, uniformDraw(noiseActionTable[action]))
    }))
  };
};


// All params for gridworld
var makeBlockedGridParams = function(xLim, yLim, blockedStates, terminals, utilityFunction, transitionNoiseProb, alpha, labels){
  var t = transitionNoiseProb==0 ? makeGridTransition(xLim, yLim, blockedStates, terminals) : 
      makeStochasticGridTransition(xLim, yLim, blockedStates, transitionNoiseProb, terminals)
  return {utility: utilityFunction,
          transition: t,
          actions: gridActions,
          terminals: terminals,
          alpha: alpha,
          blockedStates: blockedStates,
          xLim: xLim,
          yLim: yLim, 
          labels : labels};
};


// Map states to their features and then display via JS library function
var displayGrid = function(params){
  var u = params.utility;
  var states = GridWorld.getGridStates(params.xLim, params.yLim);

  var out = map( function(state){
    if ( stateInArray(state, params.blockedStates) ){return '#';}
    if ( stateInArray(state, params.terminals) ){return u(state,'u')+'t';}
    if ( u(state,'u') != 0 ){ return JSON.stringify(u(state,'u'));}
    if ( true ){return '_';}
  }, states);

  var zipGrid = zip(states,out);
  GridWorld.zipToDisplayGrid( zipGrid, params.xLim, params.yLim);
  return zipGrid;
};


// 3x3 grid where you go from anywhere to top-right
var _makeSmall = function(transitionNoiseProb, alpha, xLim, yLim){
  var u = function(state,action){
    if (gridEqual(state,[2,2])){return 1;}
    if (isPostTerminal(state)){return 0;}
    return -0.05;
  };
  var blockedStates = [];
  var terminals = [ [2,2]];
  return makeBlockedGridParams(xLim, yLim, blockedStates, terminals, u, transitionNoiseProb, alpha);
};

var makeSmall = function(transitionNoiseProb, alpha){return _makeSmall(transitionNoiseProb, alpha, 3, 3);};


// Russell-Norvig basic example
var make43 = function(transitionNoiseProb, alpha){
  var utility = function(state,action){
    if (gridEqual(state,[3,2]) ){ return 1;}
    if (gridEqual(state,[3,1]) ){ return -1;}
    if (isPostTerminal(state)){ return 0;}
    return -.1;
  };
  var blockedStates = [[1,1] ];
  var terminals = [[3,2], [3,1]];
  return makeBlockedGridParams(4,3, blockedStates, terminals, utility, transitionNoiseProb, alpha);
};


// Donut example from AAAI paper
var makeDonut = function(transitionNoiseProb, alpha){
  var blockedStates = [ [0,5], [1,5], [2,5],      [4,5], [5,5],
                        [0,4], [1,4],                    [5,4],  
                        [0,3],              [3,3],       
                        [0,2], [1,2],       [3,2],       [5,2],
                                                         [5,1],
                        [0,0], [1,0],       [3,0], [4,0], [5,0] ];
  var terminals = [[0,1], [1,3], [5,3], [3,5] ];
  var labels = [ 
      { point : [0, 1], content : "Donut"},
      { point : [1, 3], content : "Donut"},
      { point : [3, 5], content : "Veg"},
      { point : [5, 3], content : "Noodle"},
      { point : [2, 0], content : "Start"}
  ];

  var u = function(state,action){
    if (gridEqual(state,[3,5])){return 4;}
    if (isPostTerminal(state)){return 0;};
    if (stateInArray(state,terminals)){return 1;}
    return -0.1;
  };
  return makeBlockedGridParams(6,6, blockedStates, terminals, u, transitionNoiseProb, alpha, labels);
};


// Better Donut example
// *smallVersion*==false means a bigger grid that looks more like AAAI paper grid
var makeDonutInfer = function(smallVersion, utilityTable, alpha, transitionNoiseProb){
  assert.ok( typeof(smallVersion)=='boolean' & typeof(utilityTable.veg) == 'number' &
             typeof(utilityTable.timeCost) == 'number' & alpha >= 0 & transitionNoiseProb >= 0, 'makeDonutInfer args');

  var smallParams = {openStates : [ [0,0], [0,1],
                                    [1,1], [1,4],
                                    [2,0], [2,1], [2,2], [2,3], [2,4], [2,5],
                                    [3,3], [3,5], [3,6],
                                    [4,2], [4,3], [4,4], [4,5] ],
                     xLim: 5, yLim: 7,
                     terminals:  [[0,0], [1,4], [4,2], [3,6] ],
                     stateToRestaurantTable: { '[0,0]': 'donutSouth',
                                               '[1,4]': 'donutNorth', 
                                               '[3,6]': 'veg',
                                               '[4,2]': 'noodle' },
                     defaultStartState : [2,0]
                    };
  
  var bigParams = {openStates: [[0,0], [0,1],
                                [1,1],
                                [2,1], [2,5],
                                [3,0], [3,1], [3,2], [3,3], [3,4], [3,5], [3,6],
                                [4,3], [4,6], [4,7],
                                [5,2], [5,3], [5,4], [5,5], [5,6] ],
                   xLim: 6, yLim: 8,
                   terminals:  [[0,0], [2,5], [5,2], [4,7] ],
                   stateToRestaurantTable: { '[0,0]': 'donutSouth',
                                             '[2,5]': 'donutNorth', 
                                             '[4,7]': 'veg',
                                             '[5,2]': 'noodle' },
                   defaultStartState : [3,0]

                  };
  
  var params = smallVersion ? smallParams : bigParams;
  var smallLabels = [
      { point: [0,0], content: 'Donut' },
      { point: [1,4], content: 'Donut' },
      { point: [3,6], content: 'Veg' },
      { point: [4,2], content: 'Noodle' }
  ];
  var bigLabels = [
      { point: [0,0], content: 'Donut' },
      { point: [2,5], content: 'Donut' },
      { point: [4,7], content: 'Veg' },
      { point: [5,2], content: 'Noodle' }
  ];
  var labels = smallVersion ? smallLabels : bigLabels;
  var blockedStates = openToBlocked(params.openStates, params.xLim, params.yLim);

  var stateToRestaurant = function(state){
    var table = params.stateToRestaurantTable;
    return table[JSON.stringify(state)] ? table[JSON.stringify(state)] : false;
  };
  
  var u = function(state,action){
    if (isPostTerminal(state)){return 0;};
    if (stateToRestaurant(state)){return utilityTable[ stateToRestaurant(state) ];}
    return utilityTable['timeCost'];
  };
  var outParams = makeBlockedGridParams(params.xLim, params.yLim, blockedStates, params.terminals, u, transitionNoiseProb, alpha);
  return update(outParams, {defaultStartState : params.defaultStartState, labels : labels});
};


var makeHike = function(transitionNoiseProb, alpha, utilityEast, utilityWest, utilityHill, timeCost){
  map( function(input){assert.ok( typeof(input)=='number', 'makeHike inputs' );}, [transitionNoiseProb, alpha, utilityEast, utilityWest, utilityHill, timeCost] );
  assert.ok(timeCost <=0, 'makeHike inputs' );
  assert.ok(transitionNoiseProb >= 0 & alpha >= 0, 'makeHike inputs' );

  
  var xLim = 5;
  var yLim = 5;
  var blockedStates = [ [1,2], [1,3], [3,2] ];
  var terminals = [ [0,0], [1,0], [2,0], [3,0], [4,0], [2,2], [4,2] ]; 

  var u = function(state,action){
    if (gridEqual(state,[2,2])){return utilityWest;}
    if (gridEqual(state,[4,2])){return utilityEast;}
    if (isPostTerminal(state)){return 0;};
    if (stateInArray(state,terminals)) {return utilityHill;}
    return timeCost;
  };
  return makeBlockedGridParams(xLim, yLim, blockedStates, terminals, u, transitionNoiseProb, alpha);
};





// MDP AGENT

// *actualTotalTime*: how many steps we run *simulate* for
// *perceivedTotalTime*: how many steps agent perceives in the future (*actualTotalTime* could be less)

// *mdpParams*: has *transition*, *utility*, *alpha* as attributes. For gridworld, constructor is *makeBlockedGridParams*.

// *outputParams* specify options for (a) the form of the ERP over trajectories (the main output of *mdpSimulate*)
// and (b) extra outputs such as *expUtility(state,action)* for state-action pairs and ERPs for each state
// given in *conditionOnStates*.

// Attributes for *outputParams* are:

// *trajectoryNumRejectionSamples*: if set to zero, use Enumerate for simulating trajectories, otherwise use Rejection
// with given number of samples.

// *erpOverStatesOrActions*: *simulate* either outputs states, actions, or both ([state,action]). Values are following strings:
// 'states', 'actions', 'both'. 

// *conditionOnStates* should be a state sequence, typically with length == perceivedTotalTime. If not conditioning on
// states, set to false.


var mdpSimulate = function(startState, actualTotalTime, perceivedTotalTime, mdpParams, outputParams){

  // CHECK AND ABBREVIATE INPUT ARGS
  // shorten variable names for convenience
  var params = mdpParams;
  var erpOverStatesOrActions = outputParams.erpOverStatesOrActions;

  assert.ok(perceivedTotalTime >= actualTotalTime  &  mdpParams.alpha >= 0  & 
            (['actions','states','both'].indexOf(outputParams.erpOverStatesOrActions) > -1)  &
            outputParams.trajectoryNumRejectionSamples >= 0, 'mdpSimulate args');
  
  if (outputParams.conditionOnStates){
    assert.ok( outputParams.conditionOnStates.length >= 0, 'conditionOnStates argument');}

  
  // FIX CHECKING FOR TERMINAL STATES
  var terminalCheck = true; // toggle whether trajectory end sat terminals (if false, agent stays in postTerminal state --
  // this is equivalent in terms of the agent's plans but means sequences of states are longer)

  // At a terminal, agent takes a single action and then transitions to a "postTerminal" state
  // which has form [ 'dead', [x,y] ] where [x,y] is terminal's coordinates.
  var isTerminal = function(state){return terminalCheck & isPostTerminal(state);}; 


  var agent = cache( 
    function(_agent, _expUtility, state, timeLeft, params){
     
      return Enumerate(function(){
        var action = uniformDraw(params.actions);
        var eu = _expUtility(_agent, _expUtility, state, action, timeLeft, params);    
        factor(params.alpha * eu);
        return action;
      });      
    });

  
  var expUtility = cache(
    function(_agent, _expUtility, state, action, timeLeft, params){
      var utility = params.utility;
      var u = utility(state,action);
      
      if (timeLeft - 1 == 0 | isTerminal(state)){
        return u; 
      } else {                     
        return u + expectation( Enumerate(function(){
          var transition = params.transition;
          var nextState = transition(state, action); 
          var nextAction = sample(_agent(_agent, _expUtility, nextState, timeLeft-1, params));
          return _expUtility(_agent, _expUtility, nextState, nextAction, timeLeft-1, params);  
        }));
      }                      
    });

  
  // GET DISTRIBUTION ON TRAJECTORIES
  var simulate = function(startState, actualTotalTime, perceivedTotalTime, params, erpOverStatesOrActions){

    var sampleSequence = function(state, actualTimeLeft, perceivedTimeLeft){
      if (actualTimeLeft==0 | isTerminal(state)){
        return [];
      } else {
        var action = sample(agent(agent, expUtility, state, perceivedTimeLeft, params));
        var transition = params.transition;
        var nextState = transition(state,action); 
        var out = {states:state, actions:action, both:[state,action]}[erpOverStatesOrActions];
        return [ out ].concat( sampleSequence(nextState,actualTimeLeft-1, perceivedTimeLeft-1));
      }
    };
    // Either enumerate over trajectories or use rejection
    return outputParams.trajectoryNumRejectionSamples==0 ? 
      Enumerate(function(){
        return sampleSequence(startState, actualTotalTime, perceivedTotalTime); 
      }) : 
    Rejection(function(){
      return sampleSequence(startState, actualTotalTime, perceivedTotalTime); 
    }, outputParams.trajectoryNumRejectionSamples, undefined, true);
  };


  // GET ADDITIONAL CACHED OUTPUTS
  
  // Get expU for each state visited in MAP() and for all four possible actions
  // output has form: [ [state0,[EU(state0,'l'), EU(state0,'r'), EU(state0,'u'), EU(state0,'d') ] ], .... ]
  // TODO give some warning because expUtilities are misleading for single action
  var getExpUtility = function(){
    
    var erp = simulate(startState, actualTotalTime, perceivedTotalTime, params, 'states');
    var states = erp.MAP().val;
    var timeStates = zip(downToOne(states.length), states);
    
    return map( function(timeState){
      return [JSON.stringify(timeState[1]), map(function(action){
        return expUtility(agent, expUtility, timeState[1], action, timeState[0], params);
      }, params.actions)];
    }, timeStates);
   
  };

  // Input is a sequence of states, typically an observed agent trajectory. 
  // States are assumed to be ordered and to start at startState.
  // *timeStates* = [ [t, states[0]], [t-1, states[1] ], ... ], where t is *perceivedTotalTime*
  var getStateActionERPs = function( states ){
    var timeStates = zip(downToOne(perceivedTotalTime).slice(0,states.length), states); // assumes states begin at start
    return map( function(timeState){
      var time = timeState[0];
      var state = timeState[1];
      return agent(agent, expUtility, state, time, params);
    }, timeStates);
  };

  
  // ASSEMBLE OUTPUTS

  // standard output is ERP over state, action or state-action sequences
  var erp = simulate(startState, actualTotalTime, perceivedTotalTime, params, erpOverStatesOrActions);

  // extra outputs: normally using values already cached by simulate
  var expUtilityValues = outputParams.getExpUtilityValues ? getExpUtility() : [];
  var stateActionERPs = outputParams.conditionOnStates != false ? 
      getStateActionERPs(outputParams.conditionOnStates) : [];
  
  return {erp: erp, expUtilityValues: expUtilityValues, stateActionERPs: stateActionERPs }; 
  
};









// THIS IS USED IN CHAPTER 5. TODO: USE MORE DESCRIPTIVE NAMES.
// *mdpSimulate* function above should be used for inference/MDP experiments
var mdpSimulateTemp = function(startState, totalTime, params, numRejectionSamples){
  var alpha = params.alpha;
  var transition = params.transition;
  var utility = params.utility;
  var actions = params.actions;
  var isTerminal = function(state){return state[0]=='dead';};


  var agent = dp.cache(function(state, timeLeft){
    return Enumerate(function(){
      var action = uniformDraw(actions);
      var eu = expUtility(state, action, timeLeft);    
      factor( alpha * eu);
    return action;
    });      
  });
  
  
  var expUtility = dp.cache(function(state, action, timeLeft){
    var u = utility(state,action);
    var newTimeLeft = timeLeft - 1;
    
    if (newTimeLeft == 0 | isTerminal(state)){
      return u; 
    } else {                     
      return u + expectation( Enumerate(function(){
        var nextState = transition(state, action); 
        var nextAction = sample(agent(nextState, newTimeLeft));
        return expUtility(nextState, nextAction, newTimeLeft);  
      }));
    }                      
  });
  
  var simulate = function(startState, totalTime){
  
    var sampleSequence = function(state, timeLeft){
      if (timeLeft == 0 | isTerminal(state)){
        return [];
      } else {
      var action = sample(agent(state, timeLeft));
        var nextState = transition(state,action); 
        return [[state,action]].concat( sampleSequence(nextState,timeLeft-1 ))
      }
    };
    return Rejection(function(){return sampleSequence(startState, totalTime);}, numRejectionSamples);
  };

  return simulate(startState, totalTime);
};










