// home-club game:
// there are two agents. The agents are in general antisocial, and like being
// home alone, but especially enjoy hanging out with each other. They both
// separately face a choice of staying home alone or going out to a club. If
// an agent stays at home, they get a utility of 5. If they go to the club,
// and the other agent is there, they get a utility of 10, and otherwise they
// get a utility of 0.

var makeHomeClubGame = function(){

  var locs = ['start', ['club', 'home'], ['home', 'home'], ['club', 'club'],
	      ['home', 'club']];

  var nonTerminalLocs = ['start'];

  var actions = ['home', 'club'];

  var transition = function(state, action0, action1){
    var loc = state.loc;
    if (loc !== 'start') {
      return {loc: loc,
	      terminateAfterAction: true};
    } else {
      return {loc: [action0, action1],
	      terminateAfterAction: true};
    }
  };

  var homeClubUtility0 = function(state) {
    var loc = state.loc;
    if (loc === 'start') {
      return 0;
    } else if (loc[0] === 'home') {
      return 5;
    } else {
      return loc[1] === 'home' ? 0 : 9;
    };
  };

  var homeClubUtility1 = function(state) {
    var loc = state.loc;
    if (loc === 'start') {
      return 0;
    } else if (loc[1] === 'home') {
      return 5;
    } else {
      return loc[0] === 'home' ? 0 : 9;
    };
  };
  
  return {
    nonTerminalLocs: nonTerminalLocs,
    actions0: actions,
    actions1: actions,
    utility0: homeClubUtility0,
    utility1: homeClubUtility1,
    transition: transition
  };
};

// doubleClub game:
// each agent has to choose between two clubs. One club (cube) is slightly
// better. Both agents prefer the better club (all else being equal), and they
// also greatly prefer to be in the same club as the other agent.

var makeDoubleClubGame = function(){

  var locs = ['start', ['mooseheads', 'cube'], ['cube', 'cube'],
	      ['mooseheads', 'mooseheads'], ['cube', 'mooseheads']];

  var nonTerminalLocs = ['start'];

  var actions = ['cube', 'mooseheads'];

  var transition = function(state, action0, action1){
    var loc = state.loc;
    if (loc !== 'start') {
      return {loc: loc,
	      terminateAfterAction: true};
    } else {
      return {loc: [action0, action1],
	      terminateAfterAction: true};
    }
  };

  
  var doubleClubUtility0 = function(state) {
    var loc = state.loc;
    if (loc === 'start') {
      return 0;
    } else {
      var clubUtility = loc[0] === 'cube' ? 0.001 : 0;
      var matchingUtility = loc[0] === loc[1] ? 1 : 0;
      return clubUtility + matchingUtility;
    }
  };

  var doubleClubUtility1 = function(state) {
    var loc = state.loc;
    if (loc === 'start') {
      return 0;
    } else {
      var clubUtility = loc[1] === 'cube' ? 0.001 : 0;
      var matchingUtility = loc[0] === loc[1] ? 1 : 0;
      return clubUtility + matchingUtility;
    }
  };
  
  return {
    nonTerminalLocs: nonTerminalLocs,
    actions0: actions,
    actions1: actions,
    utility0: doubleClubUtility0,
    utility1: doubleClubUtility1,
    transition: transition
  };
};

// the classic matching pennies game

var makeMatchingPenniesGame = function(){

  var locs = ['start', ['heads', 'tails'], ['tails', 'tails'],
	      ['heads', 'heads'], ['tails', 'heads']];

  var nonTerminalLocs = ['start'];

  var actions = ['tails', 'heads'];

  var transition = function(state, action0, action1){
    var loc = state.loc;
    if (loc !== 'start') {
      return {loc: loc,
	      terminateAfterAction: true};
    } else {
      return {loc: [action0, action1],
	      terminateAfterAction: true};
    }
  };

  var matchingPenniesUtility0 = function(state) {
    var loc = state.loc;
    if (loc === 'start') {
      return 0;
    } else {
      return loc[0] === loc[1] ? 1 : 0;
    }
  };

  var matchingPenniesUtility1 = function(state) {
    var loc = state.loc;
    if (loc === 'start') {
      return 0;
    } else {
      return loc[0] === loc[1] ? 0 : 1;
    }
  };
  
  return {
    nonTerminalLocs: nonTerminalLocs,
    actions0: actions,
    actions1: actions,
    utility0: matchingPenniesUtility0,
    utility1: matchingPenniesUtility1,
    transition: transition
  };
};

// bach or stravinsky (commonly known as 'battle of the sexes')

var makeBoSGame = function(){

  var locs = ['start', ['bach', 'stravinsky'], ['stravinsky', 'stravinsky'],
	      ['bach', 'bach'], ['stravinsky', 'bach']];

  var nonTerminalLocs = ['start'];

  var actions = ['stravinsky', 'bach'];

  var transition = function(state, action0, action1){
    var loc = state.loc;
    if (loc !== 'start') {
      return {loc: loc,
	      terminateAfterAction: true};
    } else {
      return {loc: [action0, action1],
	      terminateAfterAction: true};
    }
  };

  var BoSUtility0 = function(state) {
    var loc = state.loc;
    if (loc === 'start' || loc[0] !== loc[1]) {
      return 0;
    } else if (loc[0] === 'bach') {
      return 1;
    } else {
      return 5;
    }
  };

  var BoSUtility1 = function(state) {
    var loc = state.loc;
    if (loc === 'start' || loc[0] !== loc[1]) {
      return 0;
    } else if (loc[0] === 'bach') {
      return 5;
    } else {
      return 1;
    }
  };
  
  return {
    nonTerminalLocs: nonTerminalLocs,
    actions0: actions,
    actions1: actions,
    utility0: BoSUtility0,
    utility1: BoSUtility1,
    transition: transition
  };
};

// single-shot prisoner's dilemma

var makePDGame = function(){

  var locs = ['start', ['C', 'D'], ['D', 'D'],
	      ['C', 'C'], ['D', 'C']];

  var nonTerminalLocs = ['start'];

  var actions = ['D', 'C'];

  var transition = function(state, action0, action1){
    var loc = state.loc;
    if (loc !== 'start') {
      return {loc: loc,
	      terminateAfterAction: true};
    } else {
      return {loc: [action0, action1],
	      terminateAfterAction: true};
    }
  };

  var PDUtility0 = function(state) {
    var loc = state.loc;
    if (loc === 'start') {
      return 0;
    } else if (_.isEqual(loc, ['C', 'C'])) {
      return 3;
    } else if (_.isEqual(loc, ['C', 'D'])) {
      return 0;
    } else if (_.isEqual(loc, ['D', 'C'])) {
      return 5;
    } else {
      return 1;
    }
  };

  var PDUtility1 = function(state) {
    var loc = state.loc;
    if (loc === 'start') {
      return 0;
    } else if (_.isEqual(loc, ['C', 'C'])) {
      return 3;
    } else if (_.isEqual(loc, ['D', 'C'])) {
      return 0;
    } else if (_.isEqual(loc, ['C', 'D'])) {
      return 5;
    } else {
      return 1;
    }
  };
  
  return {
    nonTerminalLocs: nonTerminalLocs,
    actions0: actions,
    actions1: actions,
    utility0: PDUtility0,
    utility1: PDUtility1,
    transition: transition
  };
};

// n-round iterated prisoner's dilemma

// choice: states could either store previous action, previous two actions, or
// whole history (or previous 3 actions, or...).

// to balance desire for a small state space with a desire to let the agent
// know what's going on, we let the location store one previous pair of actions,
// as well as the number of future rounds.

var makeIPDRememberOneGame = function(n){

  var actions = ['D', 'C'];

  var actionPairs = [['C', 'C'], ['C', 'D'], ['D', 'C'], ['D', 'D']];

  var locsAtTimeI = function(i){
    return map(function(x){return [i, x];}, actionPairs);
  };

  var nonStartLocs = map(locsAtTimeI, range(n).slice(1));

  var nonTerminalLocs = _.flatten(cons('start', nonStartLocs), true);

  var transition = function(state, action0, action1){
    var loc = state.loc;
    var time = loc === 'start' ? n : loc[0];
    var nextTime = time - 1;
    var nextLoc = [nextTime, [action0, action1]];
    // console.log(nextLoc);
    return {loc: nextLoc,
	    terminateAfterAction: nextTime === 0};
  };

  var IPDUtility0 = function(state) {
    var loc = state.loc;
    if (loc === 'start') {
      return 0;
    } else if (_.isEqual(loc[1], ['C', 'C'])) {
      return 3;
    } else if (_.isEqual(loc[1], ['C', 'D'])) {
      return 0;
    } else if (_.isEqual(loc[1], ['D', 'C'])) {
      return 5;
    } else {
      return 1;
    }
  };

  var IPDUtility1 = function(state) {
    var loc = state.loc;
    if (loc === 'start') {
      return 0;
    } else if (_.isEqual(loc[1], ['C', 'C'])) {
      return 3;
    } else if (_.isEqual(loc[1], ['D', 'C'])) {
      return 0;
    } else if (_.isEqual(loc[1], ['C', 'D'])) {
      return 5;
    } else {
      return 1;
    }
  };
  
  return {
    nonTerminalLocs: nonTerminalLocs,
    actions0: actions,
    actions1: actions,
    utility0: IPDUtility0,
    utility1: IPDUtility1,
    transition: transition
  };
};
