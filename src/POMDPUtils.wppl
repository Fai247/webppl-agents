// Helper functions for testing argument types (warning: heuristics only)

var isGreaterZero = function (x) {return _.isFinite(x) && x > 0;};
var isERP = function (x) {return _.has(x,'sample') && _.has(x,'support');};

// TODO for manifest
var stateHasManifestLatent = function (x){return _.has(x,'latentState') && _.isFinite(x.manifestState.timeLeft);};
var isGridworld = function(world){return arraysEqual(world.actions, ['l', 'r', 'u', 'd']);};



// TODO works for manifest
var isPOMDPWorld = function(world){ 
  return hasProperties(world, ['transition', 'manifestStateToActions', 'observe']);
};


var hasUtilityPriorBelief = function(agentParams){
if ( _.has(agentParams,'utility') && _.has(agentParams, 'priorBelief') ){
  var utility = agentParams.utility;
  var priorBelief = agentParams.priorBelief;
  return _.isFunction(utility);
  }
  return false;
};

var hasTransitionObserve = function(world){
  if ( _.has(world,'transition') && _.has(world,'observe') ){
    var transition = world.transition;
    var observe = world.observe;
    return _.isFunction(transition) && _.isFunction(observe);
  }
  return false;
};


var inSupport = function(x, erp){return _.isFinite( erp.score([], x) ); };
                   

// Helper functions

// TODO works only for manifest
var buildState = function (manifestState, latentState) {
  return { manifestState:manifestState, latentState:latentState };
};


// Convenient distributions
var categoricalERP = function(probs, vals) {
  return Enumerate(function(){
    return categorical(probs, vals);
  });
};


// TODO: should not all be global

// From array of POMDP states, extract locations array
var trajectoryToLocations = function(trajectory){
  assert.ok(_.isArray(trajectory));
  return _.map(_.map(trajectory,'manifestState'),'loc');
};

// From array of locs, add *timeLeft* and *terminateAfterAction*
var locationsToManifestStates = function(locs){
  return map( function(locTime){ 
    var terminateAfterAction = locTime[1]==1;
    return {loc: locTime[0], timeLeft:locTime[1], terminateAfterAction: terminateAfterAction};
  }, zip( locs, downToOne(locs.length) ) );
};

// As above, but outputting a [[state, action]] array, such that the actions
// transition to the correct states
var locationsToStateActions = function(locs){
  var locActions = locationsToLocActions(locs);
  var stateActions = stateActionPairsToMDPStates(locActions);
  return stateActions;
};

var locationsToLocActions = function(locs) {
  var addAction = function(index) {
    if (index === locs.length - 1) {
      return [locs[index], 'l'];
    } else {
      var firstLoc = locs[index];
      var secondLoc = locs[index + 1];
      if (secondLoc[0] > firstLoc[0]) {
	return [firstLoc, 'r'];
      } else if (secondLoc[0] < firstLoc[0]) {
	return [firstLoc, 'l'];
      } else if (secondLoc[1] > firstLoc[1]) {
	return [firstLoc, 'u'];
      } else {
	return [firstLoc, 'd'];
      }
    }
  };

  return map(addAction, range(locs.length));
};

// From array of form [ [loc, action] ], output array of form:
// [  [{loc:, timeLeft:, terminateAfterAction:}, action ]  ]
var stateActionPairsToMDPStates = function(locAction){
  var locs = map(first,locAction);
  var manifestStates = locationsToManifestStates(locs);
  return zip( manifestStates, map(second,locAction) );
};


// From array of form [ [loc, action] ], output array of form:
// [  [{manifestState:{loc:, timeLeft:, terminateAfterAction:}, latentState:latentState}, action ]  ]
var stateActionPairsToFullStates = function(locAction, latentState){
  var locs = map(first,locAction);
  var manifestStates = locationsToManifestStates(locs);
  var fullStates = map( function(manifest){
    return buildState(manifest,latentState);
    }, manifestStates);
  
  return zip( fullStates, map(second,locAction) );
};


// TODO where is this used?
var _getPriorBelief = function(perceivedTotalTime, startingLocation, latentStateSampler){
  var startManifestState = {timeLeft: perceivedTotalTime, loc: startingLocation, terminateAfterAction: false};
  
  return Enumerate( function(){
    var latentState = latentStateSampler();
    return buildState(startManifestState, latentState);
  });
};

// TODO move from here
var getPriorBeliefGridworld = function(startManifestState, latentStateSampler){
  return Enumerate( function(){
    var latentState = latentStateSampler();
    return buildState(startManifestState, latentState);
  });
};


