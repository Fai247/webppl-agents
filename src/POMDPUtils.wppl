// Helper functions for testing argument types (warning: heuristics only)

var isGreaterZero = function (x) {return _.isFinite(x) && x > 0;};
var isERP = function (x) {return hasProperties(x,['sample', 'support']);};
var isPOMDPState = function (x) {x.hasOwnProperty('latentState') && _.isFinite(x.manifestState.timeLeft);};
var isGridworld = function(world){return arraysEqual(world.actions, ['l', 'r', 'u', 'd']);};


var isPOMDPWorld = function(world){ hasProperties(world, ['transition', 'manifestStateToActions', 'observe']);};

var inSupport = function(x, erp){return _.isFinite( erp.score([], x) ); };
                   

// Helper functions

var buildState = function (manifestState, latentState) {
  return { manifestState:manifestState, latentState:latentState };
};

var downToOne = function(n){
  if (n==0){return [];}
  else {return [n].concat(downToOne(n-1));}
};


// From array of POMDP states, extract locations array
var trajectoryToLocations = function(trajectory){
  assert.ok(_.isArray(trajectory) && isPOMDPState(trajectory[0]), 'trajectory to locations args');
  return _.map(trajectory,'manifestState.loc');
};

// From array of locs, add *timeLeft* and *terminateAfterAction*
var locationsToManifestStates = function(locs){
  return map( function(locTime){ 
    var terminateAfterAction = locTime[1]==1;
    return {loc: locTime[0], timeLeft:locTime[1], terminateAfterAction: terminateAfterAction};
  }, zip( locs, downToOne(locs.length) ) );
};

// From array of form [ [loc, action] ], output array of form:
// [  [{manifestState:{loc:, timeLeft:, terminateAfterAction:}, latentState:latentState}, action ]  ]
var stateActionPairsToFullStates = function(locAction, latentState){
  var locs = map(first,locAction);
  var manifestStates = locationsToManifestStates(locs);
  var fullStates = map( function(manifest){
    return buildState(manifest,latentState);
    }, manifestStates);
  
  return zip( fullStates, map(second,locAction) );
};
