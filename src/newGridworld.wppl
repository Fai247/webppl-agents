var inGrid_ = function(gridMap, loc) {
  return (loc[0] >= 0 && loc[0] < gridMap.xLim &&
          loc[1] >= 0 && loc[1] < gridMap.yLim);
}

var isBlockedLoc = function(gridMap, loc) {
  var getFeature = gridMap.feature;
  var feature = getFeature({ loc : loc});
  return feature === '#';
}

var isAllowedState_ = function(gridMap, loc) {
  return (inGrid_(gridMap, loc)) && !isBlockedLoc(gridMap, loc);
};

var advanceStateTime = function(state) { 
  var dead = state.timeLeft > 0 ? state.dead : true;
  return update(state, { timeLeft : state.timeLeft - 1, dead : dead});
}

var moveState = function(gridMap, state, action) { 
    var loc = state.loc; 
    var gridTransition = {l: [loc[0]-1, loc[1]],
                          r: [loc[0]+1, loc[1]],
                          u: [loc[0], loc[1]+1],
                          d: [loc[0], loc[1]-1]};

    var possibleNextLoc = gridTransition[action];
    assert.ok(possibleNextLoc != undefined, 'action was not found');

    var nextLoc = isAllowedState_(gridMap, possibleNextLoc) ? possibleNextLoc : loc;
    return update(state, { loc : nextLoc });
}

var makeGridTransition_ = function(gridMap) {
  return function(state,action){    
    var getFeature = gridMap.feature;
    var state2 = advanceStateTime(state)

    if ( getFeature(state2).name ) { // there's a restaurant here
      var state3 =  update(state2, { digest : state2.digest -1}); 
      if (state3.digest <= 0) {
        return update(state3, { dead : true });
      }
      return state3;
    }
    return moveState(gridMap, state2, action);
  };
};

var makeGridMap = function(rfeatures)  { 
  var features = rfeatures.reverse();
  return { 
    features : features,
    xLim : features[0].length,
    yLim : features.length,
    feature : function (state) { 
      return features[state.loc[1]][state.loc[0]];
    }
  };
};

var makeStateToActions = function(transition, actions) { 
  return function (state) { 
    var possibleActions = filter(function (action) { 
      var newState = transition(state, action);
      return state.loc[0] !== newState.loc[0] || state.loc[1] !== newState.loc[1];
    }, actions);

    if (possibleActions.length > 0) {
      return possibleActions;
    } else { 
      return [actions[0]];
    }
  };
};

var restaurant = {
  donutN : { name : 'Donut N'},
  donutS : { name : 'Donut S'},
  veg   : { name : 'Veg'},
  noodle: { name : 'Noodle'}
};

var makeDonutWorld2 = function(options) { 
  var _ = ' '; 
  var DN = restaurant.donutN;
  var DS = restaurant.donutS;
  var V = restaurant.veg;
  var N = restaurant.noodle;

  var options = options || {};

  var small = 
    [['#', '#', '#',  V , '#'],
     ['#', '#',  _ ,  _ ,  _ ],  
     ['#', DN ,  _ , '#',  _ ],
     ['#', '#',  _ ,  _ ,  _ ],
     ['#', '#',  _ , '#',  N ],
     [ _ ,  _ ,  _ , '#', '#'],
     [DS , '#',  _ , '#', '#']];

  var big = 
    [['#', '#', '#', '#',  V , '#'],
     ['#', '#', '#',  _ ,  _ ,  _ ],  
     ['#', '#', DN ,  _ , '#',  _ ],
     ['#', '#', '#',  _ , '#',  _ ],
     ['#', '#', '#',  _ ,  _ ,  _ ],
     ['#', '#', '#',  _ , '#',  N ],
     [ _ ,  _ ,  _ ,  _ , '#', '#'],
     [DS , '#', '#',  _ , '#', '#']];

  var features = options.big ? big : small;
  return makeGridWorld(features);
}


var makeGridWorld = function(features) {
  var gridMap = makeGridMap(features); 

  var transition = makeGridTransition_(gridMap);
  var actions = ['l', 'r', 'u', 'd'];

  var stateToActions = function (state) { 

    var possibleActions = filter(function (action) { 
      var newState = transition(state, action);
      return state.loc[0] !== newState.loc[0] || state.loc[1] !== newState.loc[1];
    }, actions);

    if (possibleActions.length > 0) {
      return possibleActions;
    } else { 
      return [actions[0]];
    }
  };

  return update(gridMap,
    { transition : transition, 
      actions    : actions,
      stateToActions    : stateToActions,
    });
};
