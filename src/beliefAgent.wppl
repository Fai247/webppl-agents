// TODO: port refactoring of beliefDelayAgent?

// POMDP AGENT WITHOUT DELAYS
// basically the same as makeBeliefDelayAgent without delays or discounting

var makeBeliefAgent = function(params, world) {
  map(function(s){assert.ok(params.hasOwnProperty(s),'makeBeliefAgent args');}, 
      ['utility','alpha', 'priorBelief']);
  assert.ok( isPOMDP(world),
	     'world argument lacks transition, stateToActions, or observe');

  var utility = params.utility;
  var manifestStateToActions = world.manifestStateToActions;
  var transition = world.transition;
  var observe = world.observe;

  // *belief* is ERP on latent states, returns posterior ERP on latent states
  var updateBelief = dp.cache(
    function(manifestState, belief, observation){
      return observation === 'noObservation' ? belief :
	Enumerate(function(){
	  var latentState = sample(belief);
	  var state = buildState(manifestState, latentState);
	  condition(_.isEqual(observe(state), observation));
	  return latentState;
	});
    });

  var act = dp.cache(
    function(manifestState, belief) {
      assert.ok(_.isFinite(manifestState.timeLeft) && isERP(belief),
		'agent args fail');
      
      return Enumerate(function(){
	var action = uniformDraw(manifestStateToActions(manifestState));
	var eu = expectedUtility(manifestState, belief, action);
	factor(params.alpha * eu);
	return action;
      });
    });

  var expectedUtility = dp.cache(
    function(manifestState, belief, action) {
      return expectation(
	Enumerate(function(){
	  var latentState = sample(belief);
	  var state = buildState(manifestState, latentState);
	  var u = utility(state, action);
	  if (state.manifestState.dead) {
	    return u;
	  } else {
	    // change state and get an observation based on *latentState*
	    var nextState = transition(state, action);
	    var nextObservation = observe(nextState);

	    // update agent's beliefs, and have them choose an action
	    var nextBelief = updateBelief(nextState.manifestState, belief,
					  nextObservation);
	    var nextAction = sample(act(nextState.manifestState, nextBelief));

	    // compute utility given the next manifest state, the agent's new
	    // belief, and the agent's new action
	    var futureU = expectedUtility(nextState.manifestState, nextBelief,
					  nextAction);
	    return u + futureU;
	  }
	}));
    });

  return {
    act: act,
    expectedUtility: expectedUtility,
    params: params,
    updateBelief: updateBelief};
};

var simulateBeliefAgent = function (startState, world, agent, actualTotalTime,
				    outputType) {

  var perceivedTotalTime = startState.manifestState.timeLeft;
  assert.ok( isPOMDP(world),
	     'world argument lacks transition, stateToActions, or observe');
  assert.ok( actualTotalTime <= perceivedTotalTime && isState(startState),
	     'simulate args');
  assert.ok( perceivedTotalTime  > 1, 'perceivedTime<=1. If=1 then should have state.dead, but then simulate wont work');

  var agentAct = agent.act;
  var priorBelief = agent.params.priorBelief;
  var agentUpdateBelief = agent.updateBelief;
  var transition = world.transition;
  var observe = world.observe;

  var selectOutput = function(state, nextAction, currentBelief){
    var table =  {
      states:state,
      actions:nextAction,
      stateAction:[state, nextAction], 
      stateBelief: [state, currentBelief]
    };
    assert.ok( _.has(table,outputType), "outputType key not in ['states', 'actions', 'stateAction', 'stateBelief']");
    return table[outputType];
  };
  
  var shouldTerminate = function (actualTimeLeft, state) {
    return actualTimeLeft === 0 || state.dead;
  };

  var sampleSequence = function(state, belief, actualTimeLeft) {
    if (shouldTerminate(actualTimeLeft, state.manifestState) ) {
      return [];
    } else {
      var nextObservation = observe(state);

      // update agent's internal state and get action
      var nextBelief = agentUpdateBelief(state.manifestState, belief,
					 nextObservation);
      var nextAction = sample(agentAct(state.manifestState, nextBelief));

      // update world state, return immediate output and output from recursing
      // on updated world state, agent belief, and time.
      var nextState = transition(state, nextAction);
      var output = selectOutput(state, nextAction, belief);

      return [output].concat( sampleSequence(nextState, nextBelief,
					     actualTimeLeft - 1));
    }
  };
  return sampleSequence(startState, priorBelief, actualTotalTime);
};
