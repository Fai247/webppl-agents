// POMDP AGENT WITHOUT DELAYS
// basically the same as makeBeliefDelayAgent without delays or discounting

var makeBeliefAgent = function(agentParams, world) {
  map(function(s){assert.ok(agentParams.hasOwnProperty(s),'makeBeliefAgent args');}, 
      ['utility','alpha', 'priorBelief']);
  assert.ok( isPOMDP(world),
	     'world argument lacks transition, stateToActions, or observe');

  var utility = agentParams.utility;

  var manifestStateToActions = world.manifestStateToActions;
  var transition = world.transition;
  var observe = world.observe;

  var updateBelief = dp.cache(
    function(manifestState, currentBelief, observation){
      return observation === 'noObservation' ? currentBelief :
	Enumerate(function(){
	  var latentState = sample(currentBelief);
	  var state = buildState(manifestState, latentState);
	  condition(_.isEqual(observe(state), observation));
	  return latentState;
	});
    });

  var agent = dp.cache(
    function(manifestState, currentBelief, observation) {
      assert.ok(_.isFinite(manifestState.timeLeft) && isERP(currentBelief),
		'agent args fail');

      var newBelief = updateBelief(manifestState, currentBelief, observation);
      
      return Enumerate(function(){
	var action = uniformDraw(manifestStateToActions(manifestState));
	var eu = expectedUtility(manifestState, newBelief, action);
	factor(agentParams.alpha * eu);
	return {action: action, belief: newBelief};
      });
    });

  var expectedUtility = dp.cache(
    function(manifestState, currentBelief, action) {
      // var eu =  expectation(
      // 	Enumerate(function(){
      // 	  var latentState = sample(currentBelief);
      // 	  var state = buildState(manifestState, latentState);

      // 	  var u = utility(state, action);

      // 	  if (state.manifestState.dead) {
      // 	    return u;
      // 	  } else {
      // 	    var nextState = transition(state, action);
      // 	    var nextAction = sample(agent(nextState.manifestState,
      // 					  currentBelief,
      // 					  observe(nextState)));
      // 	    var futureU = expectedUtility(nextState.manifestState,
      // 					  nextAction.belief,
      // 					  nextAction.action);
      // 	    return u + futureU;
      // 	  }
      // 	}));

      // console.log(manifestState, action, eu);
      
      return expectation(
	Enumerate(function(){
	  var latentState = sample(currentBelief);
	  var state = buildState(manifestState, latentState);

	  var u = utility(state, action);

	  if (state.manifestState.dead) {
	    return u;
	  } else {
	    var nextState = transition(state, action);
	    var nextAction = sample(agent(nextState.manifestState,
					  currentBelief,
					  observe(nextState)));
	    var futureU = expectedUtility(nextState.manifestState,
					  nextAction.belief,
					  nextAction.action);
	    return u + futureU;
	  }
	})
      );
    });

  return {agent: agent, expectedUtility: expectedUtility, agentParams: agentParams};
};

// *simulateBeliefDelayAgent* doesn't actually refer to the delays, so I can copy and
// paste it here
var simulateBeliefAgent = function (startState, world, agent, actualTotalTime,
				    outputStatesOrActions) {
  assert.ok( isPOMDP(world),
	     'world argument lacks transition, stateToActions, or observe');
  var perceivedTotalTime = startState.manifestState.timeLeft;
  assert.ok( actualTotalTime <= perceivedTotalTime && isState(startState),
	     'simulate args');
  assert.ok( perceivedTotalTime  > 1, 'perceivedTime<=1. If=1 then should have state.dead, but then simulate wont work');

  var agentAction = agent.agent;
  var priorBelief = agent.agentParams.priorBelief;
  var transition = world.transition;
  var observe = world.observe;

  var cutoffCondition = function (actualTimeLeft, state) {
    return actualTimeLeft === 0 || state.dead;
  };

  var sampleSequence = function(state, currentBelief, actualTimeLeft) {
    if (cutoffCondition(actualTimeLeft, state.manifestState) ) {
      return [];
    } else {
      var nextAction = sample(agentAction(state.manifestState, currentBelief,
					  observe(state)));
      var nextState = transition(state, nextAction.action);

      var out = {states:state, actions:nextAction.action,
		 both:[state, nextAction.action],
                 stateBelief: [state, currentBelief]}[outputStatesOrActions];
      
      return [out].concat( sampleSequence(nextState, nextAction.belief,
					  actualTimeLeft - 1));
    }
  };
  return sampleSequence(startState, priorBelief, actualTotalTime);
};
