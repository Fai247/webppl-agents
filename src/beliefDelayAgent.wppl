// BELIEF DELAY AGENT

// Test script by running:
//webppl tests/beliefDelayIRLBandits.wppl --require webppl-timeit --require webppl-dp --require .


// Example of well-formed *params* argument for makeBeliefDelayAgent.
// See more examples in tests/beliefDelayIRLBandits.wppl
var exampleMakeAgentParams = {
  alpha: 100,
  noDelays: false,
  discount: 2,
  sophisticatedOrNaive: 'sophisticated',
  myopia: {on:false, bound:0},
  priorBelief: {}, // see the examples mentioned above
  boundVOI: {on:false, bound:0}
};

// optional arguments are recurseOnStateOrBelief, fastUpdateBelief, and
// discountFunction.


var makeBeliefDelayAgent = function (params, world){

  assert.ok( hasProperties(params, ['utility','alpha','discount','sophisticatedOrNaive', 
                                    'priorBelief', 'noDelays', 'myopia', 'boundVOI']), 
             'makeBeliefDelayAgent args  \n'+JSON.stringify(params));
  assert.ok( isPOMDPWorld(world), 'makeBeliefDelay world is not world' );
  assert.ok( params.myopia.on === false || params.boundVOI.on === false, "one of myopia and boundVOI must be false");
  
  if (params.myopia.on || params.boundVOI.on){
    assert.ok( params.noDelays === false && params.sophisticatedOrNaive=== 'naive', 
    'myopia and boundVOI require Naive agent with delays');
  }

  // Use optimizations that for Gridworld/Bandits for POMDP agents
  var params = update({recurseOnStateOrBelief: 'belief',
		       fastUpdateBelief : true}, params);

  // Variables for methods
  var transition = world.transition;
  var utility = params.utility;
  var manifestStateToActions = world.manifestStateToActions;

  var worldObserve = world.observe;
  var observe = getFullObserve(worldObserve);
  var beliefToActions = getBeliefToActions( manifestStateToActions );
  var recurseOnStateOrBelief = params.recurseOnStateOrBelief;
  var paramsDiscountFunction = params.discountFunction;
  

  // Update the *delay* parameter in *expectedUtility* for sampling actions and future utilities
  var transformDelay = function(delay){
    var table = {naive: delay + 1, sophisticated: 0 };
    return params.noDelays ? 0 : table[params.sophisticatedOrNaive];
  };
  
  var incrementDelay = function(delay){
    return params.noDelays ? 0 : delay + 1;
  };

  // Define the discount function to be used
  var discountFunction = paramsDiscountFunction ? paramsDiscountFunction
	: function(delay){return 1.0/(1 + params.discount * delay);};

  // Termination condition for *expectedUtility*
  var shouldTerminate = function(state, delay) {
    if (state.manifestState.terminateAfterAction) {
      return true;
    }
    if (params.myopia.on) {
      return delay >= params.myopia.bound;
    }
    return false;
  };

  
  var _updateBelief = params.fastUpdateBelief ? getUpdateBeliefLatent(transition, observe) :
      getUpdateBeliefSimple(transition, observe);

  
  var updateBelief = function (belief, observation, action, delay) {
    if (params.boundVOI.on && (delay > params.boundVOI.bound)){
            
      // update manifestState (assuming no possibility that isNullAction(action))
      var nextBelief = Enumerate(function(){  
        var state = sampleBelief(belief);
        return transition(state,action); 
      });
      return params.fastUpdateBelief ? toERPOverLatent(nextBelief) : nextBelief;
      
    } else {
      return _updateBelief(belief, observation, action);
    }
  };

  // RECURSE ON BELIEF (BELLMAN STYLE)
  var act = dp.cache(
    function (belief, delay) {
      assert.ok( _.isFinite(delay), 'act: delay non-finite. delay: ' + delay);
      return Enumerate(function () {
        var action = uniformDraw(beliefToActions(belief));
        var eu = expectedUtilityBelief(belief, action, delay);
        factor(params.alpha * eu);
        return action;
      });
    });

  var expectedUtilityBelief = dp.cache(
    function (belief, action, delay) {
      return expectation(
        Enumerate(function () {
          var state = sampleBelief(belief);
	  assert.ok(_.isFinite(utility(state, action)), 'utility is not finite. state: '
		    + JSON.stringify(state));
          var u = discountFunction(delay) * utility(state, action);

          if (shouldTerminate(state, delay)){
            return u;
          } else {
            var nextState = transition(state, action);

	    var nextObservation = observe(nextState);
            var transformedDelay = transformDelay(delay);

	    var nextBelief = updateBelief(belief, nextObservation, action, transformedDelay); 
	    var nextAction = sample(act(nextBelief, transformedDelay));
            
	    var futureU = expectedUtilityBelief(nextBelief, nextAction, incrementDelay(delay));
	    return u + futureU;
          }
        }));
    });

  // RECURSE ON STATE (FIXES THE LATENT STATE)
  var act_recState = dp.cache(
    function(belief, delay) {
      assert.ok( _.isFinite(delay), 'act: delay non-finite. delay: ' + delay);
      return Enumerate(function(){
	var action = uniformDraw(beliefToActions(belief));
	var eu = expectedUtilityBelief_recState(belief, action, delay);
	factor(params.alpha * eu);
	return action;
      });
    });

  var expectedUtilityBelief_recState = dp.cache(
    function(belief, action, delay){
      return expectation(
        Enumerate( function(){
          var state = sampleBelief(belief);
          return expectedUtilityState_recState(belief,state, action, delay);
        }));
    });
  
  var expectedUtilityState_recState = dp.cache(
    function(belief, state, action, delay){
      return expectation(  // need this for caching
        Enumerate( function(){
	  assert.ok(_.isFinite(utility(state, action)), 'utility is not finite. state: '
		    + JSON.stringify(state));
          var u = discountFunction(delay) * utility(state, action);
          if (shouldTerminate(state, delay)) {
	    return u;
          } else {
	    var nextState = transition(state, action);
	    var nextObservation = observe(nextState);
	    var transformedDelay = transformDelay(delay);
	    var nextBelief = updateBelief(belief, nextObservation, action,
					  transformedDelay);
	    var nextAction = sample(act_recState(nextBelief, transformedDelay));
            var futureU = expectedUtilityState_recState(nextBelief, nextState,
							nextAction,
							incrementDelay(delay));
	    return u + futureU; 
          }
        }));
    });

  var act = recurseOnStateOrBelief === 'belief' ? act : act_recState;
  var expectedUtility = recurseOnStateOrBelief === 'belief' ? 
	expectedUtilityBelief : expectedUtilityBelief_recState;


  return { act:act, updateBelief:updateBelief, expectedUtility : expectedUtility, params: params};
};


var simulateBeliefDelayAgent = getSimulateFunction('beliefDelay');


var getMakeAgentFunction = function(beliefOrBeliefDelay){
  assert.ok( _.includes(['belief','beliefDelay'], beliefOrBeliefDelay),
             'getMakeAgentFunction invalid input:   ' + beliefOrBeliefDelay);

  if ( beliefOrBeliefDelay == 'beliefDelay'){
    return makeBeliefDelayAgent;
  } else {
    return makeBeliefAgent;
  }
};






// TODO REWRITE EXP UTILITY IF IT NEEDS IT?

// Run *simulate*. Then use *expectedUtility* to compute the expected
// utilities of each state along the trajectory. Do this from the
// perspective of each timestep. For discounting agents, the expected
// utilities for the same state/timeLeft will change depending on how
// close the agent is to the state (as measured by *delay*).

var getExpectedUtilitiesBeliefDelayAgent = function (startState, world, agent, actualTotalTime){
  assert.ok( !agent.params.noDelays, 'Delays switched off. This function uses variation in delays.');
  
  var trajectory = simulateBeliefDelayAgent(startState, world, agent, actualTotalTime, 'stateBelief');
  
  var expectedUtility = agent.expectedUtility;
  var stateToActions = world.manifestStateToActions;

  
  var getExpectedUtilityFromTimestep = function(t){
    var trajectoryAfterT = trajectory.slice(t, trajectory.length);
    var len = trajectoryAfterT.length;
    
    return map(function(stateBelief){
      var manifestState = stateBelief[0].manifestState;
      var belief = stateBelief[1];
      var timeLeft = manifestState.timeLeft;
      var delay = len - timeLeft;
      
      return [stateBelief[0], 
              map(function(a){
                return expectedUtility(manifestState, belief, a, delay);
              }, stateToActions(manifestState))
             ];
    }, trajectoryAfterT);
  };

  var expectedUtilities = map(getExpectedUtilityFromTimestep, _.range(trajectory.length));

  return {trajectory: trajectory, expectedUtilities: expectedUtilities};
  
};
