
// Helpers
var utilityToPOMDP = function(utility) {
  return function (state) { 
    return utility(state.manifestState);
  };
};

var utilityTableToFunction = function(utilityTable,world){
  return utilityToPOMDP(makeRestaurantUtilityMDP(world,utilityTable));
};

var nameToPath = restaurantNameToPath;
var pathToName = restaurantPathToName;


// WORLD PARAMS
var gridworldMDP = makeDonutWorld2({big: true, maxTimeAtRestaurant : 2});
var world = makeGridworldPOMDP(gridworldMDP);

var trueLatentState = {'Donut N': true,
		       'Donut S': true,
		       'Veg': true,
		       'Noodle': true};

var start = {manifestState: restaurantChoiceStart, //timeLeft: 11
	     latentState: trueLatentState};

                          
// the agent's prior - agent knows starting manifest, maybe not latent

var agentPrior = getPriorBeliefGridworld( start.manifestState,
					  function(){
					    return trueLatentState;
					  });

var baseParams = {
  priorBelief : agentPrior,
  alpha : 1000,
  noDelays: false,
  myopia: {on: false, bound: 0},
  boundVOI: {on: false, bound: 0}
};

var utilityTable = {
  'Donut N' : [10, -10],
  'Donut S' : [10, -10],
  'Veg'   : [-10, 30],
  'Noodle': [-5, -5],
  'timeCost': -.01,
};


var params = update(baseParams,{
  utility: utilityTableToFunction(utilityTable,world),
  discount: 1,
  sophisticatedOrNaive: 'sophisticated'
});

var testAgent = makeBeliefDelayAgent(params, world);

// var testLocations = function(){
//   return pathToName(trajectoryToLocations(
//     simulateBeliefDelayAgent(start, world, testAgent, 'states')));
// };

var out = timeit( function(){
  return trajectoryToLocations(simulateBeliefDelayAgent(start, world, testAgent, 'states'));
} );
var path = out.value;
var time = out.runtimeInMilliseconds;
console.log('nameTo', pathToName(path),
            '\n runtime: ', time); ash();

ash();
// var pathDist = Rejection(testLocations, 10);
// printERP(pathDist);
// //assert.ok( arraysEqual(path, testLocations.slice(0,testLocations.length-1), 'check' ) );
// ash();



// INFERENCE

var conditionOnPath = function (agent, path, world, startState) {
  var agentAct = agent.act;
  var agentUpdateBelief = agent.updateBelief;
  var priorBelief = agent.params.priorBelief;
  var transition = world.transition;
  var worldObserve = world.observe;
  var observe = getFullObserve(worldObserve);

  var shouldTerminate = function (manifestState) {
    return manifestState.terminateAfterAction;
  };
  
  var _conditionOnPath = function(state, priorBelief, action, i) {
    var observation = observe(state);

    var delay = 0;

    var belief = agentUpdateBelief(priorBelief, observation, action, delay);

    var newAction = sample(agentAct(belief, delay));

    if (shouldTerminate(state.manifestState) || i >= path.length) {
      return 0;
    } else {   
      var nextState = transition(state, newAction);

      condition(_.isEqual(nextState.manifestState.loc, path[i]));

      return _conditionOnPath(nextState, belief, newAction, i+1);
    }
  };

  var startAction = 'noAction';

  return _conditionOnPath(startState, priorBelief, startAction, 1);
};

var posterior = function(observedPath) {
  return Enumerate(function () { 
    var agentUtilityTable = agentUtilityTableSampler();
    var discount = agentDiscountSampler();
    var sophistication = agentSophisticationSampler();
    var agent = makeBeliefDelayAgent({
      priorBelief : agentPrior,
      utility : pomdpUtilityFromManifestUtility(makeDonutUtility(world, agentUtilityTable)),
      alpha : 1000,
      noDelays: discount===0,
      discount: discount,
      sophisticatedOrNaive: sophistication,
      myopia: {on: false, bound: 0},
      boundVOI: {on: false, bound: 0}
    }, world);

    conditionOnPath(agent, observedPath, world, startState);

    return {
      utility : agentUtilityTable,
      discount: discount,
      sophistication: sophistication
    };
  });
};

var getPosterior = function( observedPath ){
  var thunk = function(){return posterior(observedPath)};
  var out = timeit( thunk );
  printERP(out.value);
  console.log( 'runtime in s:', .001 * out.runtimeInMilliseconds);
};

//getPosterior( nameToPath.naive);
getPosterior( nameToPath.sophisticated);

