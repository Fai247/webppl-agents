// examples of inference to be used in chapter III.
// todo: check if visualisation works.

//
// example 1
//

// first inference function: inferring restaurant utilities from a single action.
// startState is the state where the agent makes its action, observedAction is the
// action that we see, perceivedTotalTime is the lifetime that the agent thinks it has,
// and utilityPrior is a thunk that stochastically returns a table of utilities of
// terminal states and time cost. all the inference is done by enumeration.
var inferSingleAction = function(startState, observedAction, perceivedTotalTime, utilityPrior) {
    return Enumerate(function(){
	var newUtilityTable = utilityPrior();
	var newParams = makeDonutInfer(true, newUtilityTable, 100, 0);
	
	var mdpSimOptions = {trajectoryNumRejectionSamples: 0, erpOverStatesOrActions: 'actions', conditionOnStates: false};
	var actionERP = mdpSimulate(startState, 1, perceivedTotalTime, newParams, mdpSimOptions).erp;

	factor(actionERP.score([], observedAction));

	return {donutUtil: newUtilityTable['donutSouth'],
		vegUtil: newUtilityTable['veg'],
		noodleUtil: newUtilityTable['noodle']};
    });
};

var simpleUtilPrior = function(){
    if (flip()) {
	return {'donutSouth': 2,
		'donutNorth': 2,
		'veg': 1,
		'noodle': 1,
		'timeCost': -0.1};
    } else {
	return {'donutSouth': 1,
		'donutNorth': 1,
		'veg': 2,
		'noodle': 2,
		'timeCost': -0.1};
    }
};

var complexUtilPrior = function(){
    var donutUtil = uniformDraw([1,2,3]);
    var vegUtil = uniformDraw([1,2,3]);
    var noodleUtil = uniformDraw([1,2,3]);
    return {'donutSouth': donutUtil,
	    'donutNorth': donutUtil,
	    'veg': vegUtil,
	    'noodle': noodleUtil,
	    'timeCost': -0.1};
};

// we learn using simpleUtilPrior whether donuts are favoured over veg/noodle.
// however, even using complexUtilPrior, we don't learn whether veg is favoured
// over noodle, since the first action is the same whichever of those is favoured.

// viz.print(inferSingleAction([2,1], ["l"], 7, simpleUtilPrior))
// viz.print(inferSingleAction([2,1], ["u"], 7, simpleUtilPrior))
// viz.print(inferSingleAction([2,1], ["l"], 7, complexUtilPrior))
// viz.print(inferSingleAction([2,1], ["u"], 7, complexUtilPrior))

//
// example 2
//

// second inference function: inferring restaurant utilities from a
// set of trajectories. trajectories is an array of arrays of the form
// [n, [state1, action1], [state2, action2], ...], where n is the perceived total
// lifespan of the agent. utilityPrior is the same as in inferSingleAction.
var inferTrajsUtil = function(trajectories, utilityPrior) {
    return Enumerate(function(){
	var newUtilityTable = utilityPrior();
	var newParams = makeDonutInfer(true, newUtilityTable, 100, 0);

	// rerunTrajectories will be defined next: it reruns the trajectories from the beginning
	// using the new parameters.
	var newTrajsERP = Enumerate(function(){
	    return rerunTrajectories(trajectories, newParams);
	});

	factor(newTrajsERP.score([], trajectories));

	return {donutUtil: newUtilityTable['donutSouth'],
		vegUtil: newUtilityTable['veg'],
		noodleUtil: newUtilityTable['noodle']};
    });
};

// rerunTrajectory is a helper function for rerunTrajectories. It takes a trajectory
// whose first element is the perceived lifetime of the agent, and MDP parameters,
// and returns a new trajectory with the same starting point, generated by the MDP
// parameters.
var rerunTrajectory = function(trajectory, params) {
    var startState = trajectory[1][0];
    var perceivedTotalTime = trajectory[0];
    var actualTotalTime = trajectory.length - 1;
    assert.ok(typeof(perceivedTotalTime)=='number','a trajectory did not include perceived total time');
    
    var outputParams = {trajectoryNumRejectionSamples: 0, erpOverStatesOrActions: 'both', conditionOnStates: false};
    
    return cons(perceivedTotalTime,
		sample(mdpSimulate(startState, actualTotalTime, perceivedTotalTime, params, outputParams).erp));
};

// rerunTrajectories applies rerunTrajectory to every trajectory in the array.
var rerunTrajectories = function(trajectories, params) {
    return map(function(traj){return rerunTrajectory(traj, params);}, trajectories);
};

var params = makeDonutInfer(true, {'donutSouth': 1, 'donutNorth': 1, 'veg': 1, 'noodle': 1, 'timeCost': 1}, 100, 0);
var noodleTraj = [7, [[2,1], 'u'], [[2,2], 'u'], [[2,3], 'r']];
var noodleTrajs = [noodleTraj];
// GridWorld.draw(params, {trajectory: rest(noodleTraj)});
// viz.print(inferTrajsUtil(noodleTrajs, complexUtilPrior));

//
// example 3
//

// third inference function: this time, we also want to infer the time cost. Our prior
// over utilities includes our prior over the time cost as well as the prior over
// restaurant utilities.
var inferTrajsUtilTimeCost = function(trajectories, utilityPrior) {
    return Enumerate(function(){
	var newUtilityTable = utilityPrior();
	var newParams = makeDonutInfer(true, newUtilityTable, 100, 0);

	// rerunTrajectories will be defined next: it reruns the trajectories from the beginning
	// using the new parameters.
	var newTrajsERP = Enumerate(function(){
	    return rerunTrajectories(trajectories, newParams);
	});

	factor(newTrajsERP.score([], trajectories));

	return {donutUtil: newUtilityTable['donutSouth'],
		vegUtil: newUtilityTable['veg'],
		noodleUtil: newUtilityTable['noodle'],
		timeCost: newUtilityTable['timeCost']};
    });
};

var superComplexUtilPrior = function() {
    var donutUtil = uniformDraw([1,2,3]);
    var vegUtil = uniformDraw([1,2,3]);
    var noodleUtil = uniformDraw([1,2,3]);
    var timeCost = uniformDraw([-0.1, -1]);
    return {'donutSouth': donutUtil,
	    'donutNorth': donutUtil,
	    'veg': vegUtil,
	    'noodle': noodleUtil,
	    'timeCost': timeCost};
};

var dsTraj = [7, [[2,1], 'l'], [[1,1], 'l']];
var dsTrajs = [dsTraj];
// GridWorld.draw(params, {trajectory: rest(dsTraj)});
// viz.print(inferTrajsUtilTimeCost(dsTrajs, superComplexUtilPrior));

//
// example 4
//

// fourth inference function: same as inferTrajsUtil, but also performs
// inference over alpha, and therefore needs a prior for alpha.
// note: this is pretty slow.
var inferTrajsUtilAlpha = function(trajectories, utilityPrior, alphaPrior) {
    return Enumerate(function(){
	var newUtilityTable = utilityPrior();
	var newAlpha = alphaPrior();
	var newParams = makeDonutInfer(true, newUtilityTable, newAlpha, 0);

	var newTrajsERP = Enumerate(function(){
	    return rerunTrajectories(trajectories, newParams);
	});

	factor(newTrajsERP.score([], trajectories));

	return	{donutUtil: newUtilityTable['donutSouth'],
		 vegUtil: newUtilityTable['veg'],
		 noodleUtil: newUtilityTable['noodle'],
		 alpha: newAlpha};
    });
};

var dnTraj = [7, [[2,1], 'u'], [[2,2], 'u'], [[2,3], 'u'], [[2,4], 'l']];
var dnTrajs = [dnTraj];
// GridWorld.draw(params, {trajectory: dnTraj})

var crazyTrajs = [dsTraj, noodleTraj];

var maybeTipsyPrior = function() {
    return categorical([0.1, 0.9], [10, 100]);
};

var simplerUtilPrior = function(){
    var donutNoodleUtil = uniformDraw([1,2]);
    var vegUtil = uniformDraw([1,2]);
    return {'donutSouth': donutNoodleUtil,
	    'donutNorth': donutNoodleUtil,
	    'veg': vegUtil,
	    'noodle': donutNoodleUtil,
	    'timeCost': -0.1};
};
// viz.print(inferTrajsUtilAlpha(dnTrajs, simplerUtilPrior, maybeTipsyPrior))
// viz.print(inferTrajsUtilAlpha(dnTrajs, complexUtilPrior, maybeTipsyPrior))
