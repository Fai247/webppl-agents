var inGrid = function(map, loc) {
  return (loc[0] >= 0 && loc[0] < map.xLim &&
          loc[1] >= 0 && loc[1] < map.yLim);
}

var isBlockedLoc = function(map, loc) {
  var getFeature = map.feature;
  var feature = getFeature({ loc : loc});
  return feature === '#';
}

var isAllowedState = function(map, loc) {
  return (inGrid(map, loc)) && !isBlockedLoc(map, loc);
};

var moveState = function(map, state, action) { 
    console.log('move', state);
    var loc = state.loc; 
    var gridTransition = {l: [loc[0]-1, loc[1]],
                          r: [loc[0]+1, loc[1]],
                          u: [loc[0], loc[1]+1],
                          d: [loc[0], loc[1]-1]};

    console.log('move.5', action);
    var possibleNextLoc = gridTransition[action];
    console.log('move.5', possibleNextLoc);
    assert.ok(possibleNextLoc != undefined, 'action was not found');

    var nextLoc = isAllowedState(map, possibleNextLoc) ? possibleNextLoc : loc;

    console.log('move2', state);
    var dead = state.timeLeft > 0 ? state.dead : true;
    console.log("update4");
    return update(state, { loc : nextLoc, timeLeft : state.timeLeft - 1, dead : dead});
}

var makeGridTransition = function(map) {
  return function(state,action){    
    var getFeature = map.feature;

    if ( getFeature(state).name ) { // there's a restaurant here
      var state2 =  update(state, { digest : state.digest -1}); 
      if (state2.digest <= 0) {
        return update(state2, { dead : true });
      }
      return state2;
    }
    return moveState(map, state, action);
  };
};

var makeMap = function(rfeatures)  { 
  var features = rfeatures.reverse();
  return { 
    features : features,
    xLim : features[0].length,
    yLim : features.length,
    feature : function (state) { 
      return features[state.loc[1]][state.loc[0]];
    }
  };
};

var makeDonutWorldExtended = function(){
  var _ = ' '; 
  var D = { name : 'Donut'} ;
  var V = { name : 'Veg'} ;
  var N = { name : 'Noodle'} ;

  var features = [['#', '#', '#',  V , '#', '#'],
                  ['#', '#',  _ ,  _ ,  _ , '#'],  
                  ['#', D  ,  _ , '#',  _ ,  N ],
                  ['#', '#',  _ , '#',  _ , '#'],
                  ['#',  _ ,  _ ,  _ ,  _ , '#'],
                  ['#', '#',  _ , '#', '#', '#']];

  var map = makeMap(features); 

  return update(map,
      { transition : makeGridTransition(map), 
        actions    : ['l', 'r', 'u', 'd'],
      });
};

var makeDonutUtility = function (max_digest, rewards) { 
  return function(world, state, action) {
    console.log("uti", state)
    var getFeature = world.feature;
    var feature = getFeature(state);

    if (state.dead)   { return 0; }
    if (feature.name) { 
      
      console.log(rewards[feature.name][max_digest - state.digest],[max_digest - state.digest]);
      return rewards[feature.name][max_digest - state.digest]; }
    return -0.01;
  };
};


var makeHyperbolicDiscounter = function (utility, alpha, discount, sophisticatedOrNaive) {
  var agent = cache( 
    function(_agent, _expUtility, state, world, delay){
     
      return Enumerate(function(){
        
        var action = uniformDraw(world.actions);
        var eu = _expUtility(_agent, _expUtility, state, action, world, delay);    
        console.log("agent", eu, state);
        factor(alpha * eu);
        return action;
      });      
    });
  
  var expUtility = cache(
    function(_agent, _expUtility, state, action, world, delay){
      console.log("exp");
      var u = 1.0/(1 + discount*delay) * utility(world, state, action);
      
      console.log("agent u", u, state, action);
      assert.ok(u === u,"utility not valid " + u + " " + JSON.stringify(state));
      if (state.dead){
        return u; 
      } else {                     
        return u + expectation( Enumerate(function(){
          var transition = world.transition;
          var nextState = transition(state, action); 
          var perceivedDelay = { naive : delay + 1, sophisticated : 0}[sophisticatedOrNaive]; 
          var nextAction = sample(_agent(_agent, _expUtility, nextState, world, perceivedDelay));
          return _expUtility(_agent, _expUtility, nextState, nextAction, world, delay+1);  
        }));
      }                      
    });

    return {
      utility : utility,
      expUtility : expUtility,
      agent : agent,
      alpha : alpha, 
      discount : discount
    };
};

var simulate = function(state, world, agent, actualTimeLeft, statesOrActions) { 
    var agentAction = agent.agent;
    var expUtility = agent.expUtility;
    var transition = world.transition;

    if (actualTimeLeft==0 | state.dead){
      return [];
    } else {
      var action = agentAction(agentAction, expUtility, state, world, 0);
      var nextState = transition(state,sample(action)); 
      var out = {states:state, actions:action, both:[state,action]}[statesOrActions];
      return [ out ].concat( simulate(nextState, world, agent, actualTimeLeft-1, statesOrActions));
    }
}

var start = { 
  loc : [2,0],
  dead : false,
  timeLeft : 14,
  digest : 4
};

var world = makeDonutWorldExtended();
var donutUtility = makeDonutUtility(4, {
    'Donut' : [1, 0, 0, 0],
    'Veg'   : [0, 0, 0, 4],
    'Noodle': [0, 0, 0, 0]});

var agent = makeHyperbolicDiscounter(donutUtility, 500, 1, 'naive');
var agentAgent = agent.agent;
var agentExp = agent.expUtility;

var trajectory = simulate(start, world, agent, 14, 'states');
var exp = map(function(state) {
  return [state.loc, map(function (a) { return  agentExp(agentAgent, agentExp, state, a, world, 0); }, world.actions)];
}, trajectory);

GridWorld.draw(world, {trajectory : trajectory, expUtilities : exp });
