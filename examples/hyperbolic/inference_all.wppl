
// Hyperbolic Inference example 1: Naive Trajectory
// -- Goes from bottom to Donut North
// Inference should infer that Donut has [high,low] utility
// and Veg the opposite.


// TODO why does agent do weird thing when starting at [3,0]?


// Create trajectory that we'll use to condition on

var getObservations = function(world, start, pathName){
  var donutUtility = makeDonutUtility(world, {
    'Donut N' : [10, -10],
    'Donut S' : [10, -10],
    'Veg'   : [-10, 20],
    'Noodle': [0, 0]
  });
  var discount = pathName=='vegDirect' ? 0 : 1;
  var sophisticatedOrNaive = pathName=='naive' ? 'naive' : 'sophisticated';
  
  var actual_agent = makeHyperbolicDiscounter(
    { utility : donutUtility,
      alpha : 500, 
      discount : discount, 
      sophisticatedOrNaive  : sophisticatedOrNaive
    }, world);
  var observedStateAction = simulateHyperbolic(start, world, actual_agent);
  var observedLocs = getLocationsHyperbolic(observedStateAction);   
  assert.ok( _.isEqual( observedLocs, restaurantNameToPath[pathName]), 'generated matches stored');
  console.log('observed locs: ',  restaurantNameToPath[pathName]);
  return observedStateAction;
};

// Inference only on utilities of Donut and Veg

var factorSequence = function(agentAction, observedStateAction){
  map(function (stateAction) {
    var state   = stateAction[0];
    var action  = stateAction[1];
    factor(agentAction(state, 0).score([], action)) ; 
  }, observedStateAction);
};

var conditionSequence = function(world, agent, observedStateAction){
  var stateAction = Rejection( function(){return simulateHyperbolic(start, world, agent);}, 1).MAP().val;
  condition( _.isEqual(stateAction, observedStateAction));
};


var getPosteriorHyperbolic = function( priorUtilityTable, priorDiscounting, priorAlpha, observedStateAction){
  return Enumerate(function () {
    var utilityTable = priorUtilityTable();
    var discounting = priorDiscounting();
    var alpha = priorAlpha();
  
    var agent = makeHyperbolicDiscounter(
      { utility   : makeDonutUtility(world, utilityTable),
        alpha     : alpha, 
        discount  : discounting.discount, 
        sophisticatedOrNaive  : discounting.sophisticatedOrNaive,
      }, world);
    var agentAction = agent.act;
    
    factorSequence(agentAction, observedStateAction);
    
    return {utility: utilityTable, discounting: discounting, alpha: alpha };
  });
};




var world = restaurantChoiceMDP;
var start = restaurantChoiceStart;

var priorDiscounting = function(){
  return {
    discount: uniformDraw([0,1]),
    sophisticatedOrNaive: uniformDraw(['sophisticated', 'naive'])
  };
};

var priorAlpha = function(){return 500;};

var priorUtilityTable = function(){
  var Udonut1 = uniformDraw([-10,  10, 20]);
  var Udonut2 = uniformDraw([-10,  10, 20]);
  var Uveg1   = uniformDraw([-10,  10, 20]);
  var Uveg2   = uniformDraw([-10,  10, 20]);
  
  return {
    'Donut N' : [Udonut1, Udonut2],
    'Donut S' : [Udonut1, Udonut2],
    'Veg'     : [Uveg1, Uveg2],
    'Noodle'  : [0, 0]
  };
};

map( function(name){
  var posterior = getPosteriorHyperbolic(priorUtilityTable, priorDiscounting, priorAlpha, 
                                         getObservations(world, start, name));
  printTopK(posterior,4);
}, ['naive', 'sophisticated', 'vegDirect']);

// if (typeof(document) !== 'undefined') { viz.print(posterior); }
// else {printTopK(posterior,4);}

null
