// here, we see the agent go the long way around to veg. we deduce that they
// must prefer noodle to veg, and think that noodle is open, despite noodle
// actually being closed (as otherwise they would just go the short way
// around)

// helper functions - maybe delete

var myInSupport = function(x, dist){return dist.score(x) > -100; };

var getActualSupport = function(dist) {
  assert.ok(isDist(dist), 'tried to get the support of something other than an Dist');
  var hasNonNegligibleProbability = function(x) {
    return dist.score(x) > -100;
  };
  return filter(hasNonNegligibleProbability, dist.support());
};

var checkEqualDeltaDists = function(distArray) {
  assert.ok(isDist(distArray[0]) && isDist(distArray[1]),
	    'checkEqualDeltaDists applied to something other than an array of dists');
  var sample2 = function() {
    assert.ok(_.isEqual(sample(distArray[0]), sample(distArray[1])),
	      'dists not equal');
  };
  repeat(5, sample2);
};


// WORLD PARAMS
var world = getBigDonutWorld();
var feature = world.feature;

// possible latent states
var noodleClosedLatent = {'Donut N': true,
			  'Donut S': true,
			  'Veg': true,
			  'Noodle': false};

var everythingOpenLatent = {'Donut N': true,
			    'Donut S': true,
			    'Veg': true,
			    'Noodle': true};

var trueLatentState = noodleClosedLatent;

// start states
var startState = {manifestState: {loc: [3,1],
				  terminateAfterAction: false,
				  timeLeft: 10,
				  timeAtRestaurant: 1},
		  latentState: trueLatentState};

// TRUE AGENT PARAMS

// possible utility functions (agent has noodleUtilityTable)
var noodleUtilityTable = {'Donut N': 1,
			  'Donut S': 1,
			  Veg: 1,
			  Noodle: 3,
			  timeCost: -0.1};

var vegUtilityTable = {'Donut N': 1,
		       'Donut S': 1,
		       Veg: 3,
		       Noodle: 1,
		       timeCost: -0.1};

// possible priors that the agent could have (actual prior is uninformed)
var uninformedLatentStateSampler = function(){
  return flip(.8) ? everythingOpenLatent : trueLatentState;
};

var truePriorBelief = getPriorBeliefGridworld( startState.manifestState,
					       uninformedLatentStateSampler);


var trueAgentParams = extend(baseParamsNoDiscount, 
			     {priorBelief: truePriorBelief,
			      utility: tableToUtilityFunction(noodleUtilityTable,
							      feature)});
// PRIOR FOR INFERENCE PARAMS




var beliefOrBeliefDelay = 'belief';
var makeAgent = getMakeAgentFunction(beliefOrBeliefDelay);
var simulate = getSimulateFunction(beliefOrBeliefDelay);
var agentTypeAndFunctions = {type: beliefOrBeliefDelay,
			     makeAgent:makeAgent,
			     simulate: simulatePOMDP};

var alternativePriorBelief = getPriorBeliefGridworld( startState.manifestState,
						      function(){return trueLatentState;});

var priorUtilityTable = function(){
  return uniformDraw([vegUtilityTable, noodleUtilityTable]);
};
var priorAgentPrior = function(){
  return uniformDraw([truePriorBelief, alternativePriorBelief]);
};

var prior = {priorUtilityTable: Infer({ method: 'enumerate' }, priorUtilityTable),
	     priorAgentPrior: Infer({ method: 'enumerate' }, priorAgentPrior)};

// INFERENCE

var numRejectionSamples = 20;

var dists = map( function(trajectoryOrOffPolicy){
  return inferGridWorldPOMDP(world, startState, baseParamsNoDiscount,
			     trueAgentParams, prior, agentTypeAndFunctions,
			     trajectoryOrOffPolicy, numRejectionSamples);
}, ['trajectory', 'offPolicy']);

// INFERENCE TESTS

// support of trajectory should be contained in support of offPolicy (since
// trajectory is rejection sampled and offPolicy is rejection sampled)
// need to filter 'support' for things which actually have positive
// probability
// NB: this is generally applicable
var dist0ActualSupport = getActualSupport(dists[0]);

var dist1ActualSupport = getActualSupport(dists[1]);

map(function(index){
  assert.ok( myInSupport(dist0ActualSupport[index], dists[1]),
  	     'support of trajectory Dist not contained in support of offPolicy Dist');
}, _.range(dist0ActualSupport.length));

// Dists should be delta Dists (almost)

checkEqualDeltaDists(dists);

// inference should think that agent likes noodles and thought noodles were closed

assert.ok(sample(dists[1]).utilityTable['Noodle'] === 3,
	  'posterior Dist failed to infer agent liking noodles');
var agentBelief = sample(dists[1]).priorBelief;
var agentBeliefSample = sample(agentBelief);
assert.ok(agentBelief.score(agentBeliefSample) < -0.1,
	  'posterior Dist failed to infer agents uncertainty');

// true params should be in support of both dists

assert.ok(myInSupport({utilityTable: noodleUtilityTable,
  		       priorBelief: truePriorBelief}, dists[1]),
  	  'Enumeration incorrectly rules out true explanation');

assert.ok(myInSupport({utilityTable: noodleUtilityTable,
  		       priorBelief: truePriorBelief}, dists[0]),
  	  'Rejection sampling incorrectly rules out true explanation');

console.log('everything is fine');
