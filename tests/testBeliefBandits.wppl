var printOut = function ( trajectory ) {
  console.log('trajectory', map( function (state) {return state.manifestState.loc;},
				 trajectory) );
  //console.log('expUtilities', out.startEU);
};

// Multi-arm deterministic bandits.
// Rewards of arms are fixed by the latent state. 
var makeBandits = function (numArms) {
  var actions = _.range(numArms);
  
  var mdpTransition = function (state, action) {
    var terminateAfterAction = state.timeLeft - 1 == 1 ? true : false;
    return update(state, { loc:action, timeLeft:state.timeLeft - 1, terminateAfterAction:terminateAfterAction });
  };
  
  var manifestStateToActions = function (manifestState) {return actions;};

  var transition = function(state, action){
    return buildState( mdpTransition(state.manifestState, action),
		       state.latentState);
  };

  var observe = function(state){
    // agent observes the reward of arm when he chooses it
    return state.latentState[state.manifestState.loc];
  };
  
  return {manifestStateToActions: manifestStateToActions, transition:transition,
	  observe:observe};
};

// *armToRewards* is the actual rewards for each arm (true latentState)
// *priorBelief* is agent's belief about rewards,
// which must have true latentState in support
var runBandits = function(numArms, armToRewards, priorBelief,
			  perceivedTotalTime) {
  map( function(n){assert.ok(_.isFinite(armToRewards[n]),'check armTo');},
       _.range(numArms) );
  var world = makeBandits(numArms);
  
  // agent params 
  assert.ok( _.isFinite(priorBelief.score([],armToRewards)),
	     "actual latent not in prior's support" );

  var agentParams = { 
    utility: function (state,action) {
      return state.latentState[state.manifestState.loc];
    }, // utility == reward
    alpha: 100,
    priorBelief: priorBelief
  };

  var agent = makeBeliefAgent(agentParams, world);

  var actualTotalTime = perceivedTotalTime;
  var startState = {manifestState: {loc: 'start',
				    timeLeft: perceivedTotalTime,
				    terminateAfterAction: false},
		    latentState: armToRewards};

  return simulateBeliefAgent(startState, world, agent, actualTotalTime, 'states');
};


// testing bandits for *beliefAgent*. Basically the same as the tests for
// *beliefDelayAgent* on the pomdpBanditTests branch, but without the ones that
// display behaviour caused by discounting.
var testBandits = function () {

  // Agent thinks 0 is likely better. It is better and so agent stays
  var numArms = 2;
  var armToRewards = {'start':0, 0:10, 1:5}; 
  var priorBelief = Enumerate(function(){
    return flip(.8) ? armToRewards : update(armToRewards,{1:15});
  });
  var perceivedTotalTime = 3;
  var trajectory = runBandits(numArms, armToRewards, priorBelief,
			      perceivedTotalTime);
  // console.log(printOut(trajectory));
  map( function(index){assert.ok( trajectory[index].manifestState.loc == 0);},
       [1,2] );

  // Agent thinks 0 is likely better, but tries 1 for the VOI.
  // 1 is worse, so it goes back to 0.

  var priorBelief2 = Enumerate(function(){
    return flip(.6) ? armToRewards : update(armToRewards,{1:15});
  });
  var perceivedTotalTime2 = 5;
  var trajectory2 = runBandits(numArms, armToRewards, priorBelief2,
			       perceivedTotalTime2);
  assert.ok(trajectory2[1].manifestState.loc == 1);
  map( function(index){assert.ok( trajectory2[index].manifestState.loc == 0,
				  'test2');},
       [2,3] );

  // Same as above, but 1 is actually better
  var armToRewards3 = {'start': 0, 0:10, 1:15};
  var trajectory3 = runBandits(numArms, armToRewards3, priorBelief2,
			       perceivedTotalTime2);
  map( function(index){assert.ok( trajectory3[index].manifestState.loc == 1,
				  'test3');},
       [1,2,3] );

  // three arms. Explore 1, then 2, then stick with 0.
  var numArms4 = 3;
  var armToRewards4 = {'start': 0, 0: 1, 1: 0, 2: 0};
  var priorBelief4 = Enumerate(function(){
    return {
      'start': 0,
      0: 1,
      1: categorical([0.8, 0.2], [0, 200]),
      2: categorical([0.8, 0.2], [0, 150])
    };
  });
  var trajectory4 = runBandits(numArms4, armToRewards4, priorBelief4,
			       perceivedTotalTime2);
  // console.log(printOut(trajectory4));
  assert.ok( arraysEqual([1, 2, 0],
			 map(function(index){
			   return trajectory4[index].manifestState.loc;},
			     [1,2,3])),
	     'test4');

  // three arms, explore 1, then stick with 2.
  var armToRewards5 = {'start': 0, 0: 1, 1: 0, 2: 150};
  var trajectory5 = runBandits(numArms4, armToRewards5, priorBelief4,
			       perceivedTotalTime2);
  assert.ok( arraysEqual([1,2,2],
			 map(function(index){
			   return trajectory5[index].manifestState.loc;},
			     [1,2,3])),
	     'test5');
  
  console.log('passed testbandits');  
};

testBandits();                                                       
